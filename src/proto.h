#ifndef PROTO_H
#define PROTO_H

#ifdef __cplusplus
extern "C" {
#endif

// (win32/linux)_main.cpp
#ifdef _WIN32
// win32_main.c
void win32_get_window_dimension(HWND window, int* client_width, int* client_height);
LRESULT CALLBACK win32_main_window_callback(HWND window, UINT message, WPARAM wparam, LPARAM lparam);
void win32_init_game(void);
void win32_advance_frame(app_state_t* app_state);
void win32_prepare_frame(app_state_t* app_state);
void win32_end_frame(app_state_t* app_state);
// win32_sound.c
void win32_produce_sound_for_frame(app_state_t* app_state, win32_sound_output_t* sound, game_sound_buffer_t* game_sound_buffer, s64 flip_clock);
#else
void linux_advance_frame(app_state_t* app_state);
void linux_prepare_frame(app_state_t* app_state);
void linux_end_frame(app_state_t* app_state);
#endif
void message_box(const char* message);

// lowlevel.c
void display_emptypicture(void);
void display_anypicture(void);
void select_display_buffer(u8* buffer);
void InitFirstModeVideo(void);
void InitModeNormal(void);
void InitModeX(void);
void block_clear(u8* source, u8* dest);
void block_copy(u8* source, u8* dest);
void textmode(void);
void draw_sprite_deform(void);
void DisplayBufferModeNormal(u8* source, u8* dest);
void DrawWldPointPlan2Normal(u8* buffer, s32 x, s32 y);
void DrawBlackBoxNormal(u8* buffer, s32 x, s32 y, s32 height, s32 width);
void DrawFondBoxNormal(u8* buffer, s32 x, s32 y, s32 height, s32 width, u8 fond_type);
void DrawBorderBoxNormal(u8* buffer, s32 x, s32 y, s32 height, s32 width, u16 colors);
void DisplayAnyPictureNormal(u8* source_buffer, u8* dest_buffer, s32 source_x, s32 source_y, s32 dest_x, s32 dest_y, s32 stride, s32 width, s32 height);
void ClearDrawAndDisplayBufferNormal(u8* draw_buf, u8* display_buf);
void N_CLRSCR(u8* buffer);
void Swap_To_Screen(u8* draw_buf, u8* display_buf, s32 width, s32 height);
void clear_borders_Normal(u8* buffer, s32 height, s32 width);
void Copy_Plan0Diff_To_Buf(u8* source, u8* dest, s32 width, s32 height, s32 draw_width);
void Display_Bloc(void* a1, void* a2);
void Display_Bloc_Plein(void* a1, void* a2);
void Clip(void);
void Display_Bloc_Clippe(void* a1, void* a2, s16 a3, s16 a4);
void Display_Bloc_Plein_Clippe(void* a1, void* a2, s16 a3, s16 a4);
void fplot_Normal(u8* buffer, s32 x, s32 y, u8 color);
void flocon_clipping(s32 h1, s32 h2, s32 w1, s32 w2);
void draw_flocon5_Normal(void);
void draw_flocon1_Normal(void);
void draw_flocon2_Normal(void);
void draw_flocon3_Normal(void);
void draw_pluie4_Normal(void);
void draw_flocon4_Normal(void);
void draw_pluie5_Normal(void);
void draw_flocon7_Normal(void);
void draw_pluie6_Normal(void);
void draw_flocon6_Normal(void);
void draw_pluie7_Normal(void);
void get_joy_input2_dos1(u8* source_buf, u8* dest_buf, s32 width, s32 height); // ?
void get_joy_input2_dos2(u8* source_buf, u8* dest_buf, s32 width, s32 height); // ?
void get_joy_input2_windows1(u8* source_buf, u8* dest_buf, s32 width, s32 height);
void get_joy_input2_windows2(u8* source_buf, u8* dest_buf, s32 width, s32 height);
void dos_game_io_port_something(void);
void dos_game_io_port_something2(void);
void get_joy_input1_dos1(void);
void get_joy_input1_dos2(void);
void DetectCpu(void);
void default_sprite_clipping(void);
void get_sprite_clipping(s32* xmin, s32* xmax, s32* ymin, s32* ymax);
s32 get_sprite_clipping_xmin(void);
s32 get_sprite_clipping_xmax(void);
s32 get_sprite_clipping_ymin(void);
s32 get_sprite_clipping_ymax(void);
void sprite_clipping(s32 xmin, s32 xmax, s32 ymin, s32 ymax);
bool clip_sprite_on_screen(s32* x, s32* y, vec2b_t* size, u8** image_data);
bool clip_sprite_on_screen_flipped(s32* x, s32* y, vec2b_t* size, u8** image_data);
void DrawSpriteFlipNoClipX(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteX(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNoClipX(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteFlipX(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteColorX(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteColorFlipX(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNormalNoClip(s32 x, s32 color, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNormal(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNormal256(s32 x /*eax*/, s32 sprite_field_A /*edx*/, s32 y /*ebx*/, vec2b_t size /*ecx*/, u8* draw_buf /*edi*/, u8* image_data /*esi*/);
void DrawSpriteFlipNormalNoClip(s32 x, s32 color, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteFlipNormal(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteFlipNormal256(s32 x /*eax*/, s32 sprite_field_A /*edx*/, s32 y /*ebx*/, vec2b_t size /*ecx*/, u8* draw_buf /*edi*/, u8* image_data /*esi*/);
void DrawSpriteColorNormal(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteColorFlipNormal(s32 x, s32 sprite_field_A, s32 y, vec2b_t size, u8* draw_buf, u8* image_data);
bool DrawSpriteDiffNormal_clip(s32* x, s32* y, vec2b_t* size, u8** image_data);
void DrawSpriteDiffNormal(s32 x, s32 y, vec2b_t size, u8* mask, u8* draw_buf, u8* image_data);
void synchro(void);
void endsynchro(void);
void set_speaker_on(void);
void set_speaker_off(void);
void clock_ticks(void);
void wait_until(s32 target);
void speaker_enable(void);

// lowlevel.c (re-implemented from Rayman Designer)
void draw_pixel_to_display_buffer(s16 x, s16 y, u8 color);
void draw_pixel_to_buffer(u8* buffer, s16 x, s16 y, u8 color);
void draw_horizontal_line_to_display_buffer(s16 start_x, s16 start_y, s16 width, u8 color);
void draw_horizontal_line_to_draw_buffer(s16 start_x, s16 start_y, s16 width, u8 color);
void draw_vertical_line_to_display_buffer(s16 start_x, s16 start_y, s16 height, u8 color);
void draw_vertical_line_to_draw_buffer(s16 start_x, s16 start_y, s16 height, u8 color);
void draw_collision_box(s16 x, s16 y, s16 width, s16 height);
void draw_deformed_line(u8* buffer, s16 x1, s16 y1, s16 x2, s16 y2, u8 color);

// pcmain.c
void InitData(void);
void DO_GROS_MOTEUR_NORMAL(u8 need_update_display_map);
void DO_MAIN_LOOP_PC_NORMAL(u8* a1);
void DO_GROS_MOTEUR_X(u8* a1);
void DO_MAIN_LOOP_PC_X(void);
void init_arg(s32 argc, char** argv);
void PrintDosInfo(void);
void InitMemoryVariable(void);
void AllocVariablesAutorisee(void);
void AfficheEntete(void);
int main_Ray(int argc, char** argv);
void PcMain(void);

// action.c
void setBossReachingSpeeds(obj_t* obj, u8 timer, u8 accuracyX, u8 accuracyY);
s16 testActionEnd(obj_t* obj);
s16 firstFloorBelow(obj_t* obj);
void adjustBossScrollLocker(void);
void setBossScrollLimits(obj_t* obj);

// affiche.c
void display2(obj_t* obj);
void display_sprite(obj_t* obj, u8 sprite_index, s16 x, s16 y, u8 flipped);
void display_sprite_NoClip(obj_t* obj, u8 sprite_index, s16 x, s16 y, u8 flipped);
void DISPLAY_POING(void);
void DISPLAY_CLING(void);
void display_bar_boss(obj_t* boss_obj);
void DisplayCrackers(void);
void DisplayProgrammerMessage(void);
void DISPLAY_FIXE(s32 time);
void DISPLAY_POINT(s16 x, s16 y);
void DISPLAY_PTS_TO(s16 origin_x, s16 origin_y, s16 dest_x, s16 dest_y, s16 a5);
void DISPLAY_PTS_TO_PLAN2(s16 origin_x, s16 origin_y, s16 dest_x, s16 dest_y, s16 percent);
void DISPLAY_CYMBALE(obj_t* obj, u8* draw_buf, u8 a3);
void DISPLAY_ALL_OBJECTS(void);
void display_flocons_behind(void);
void display_flocons_before(void);
void display_pix_gerbes(void);
void DISPLAY_BLACKBOX(s16 x, s16 y, s16 width, s16 height, s16 font_size, u8 is_fond);
void display_text(const char* text, s16 x, s16 y, u8 font_size, s8 color);
void display_deform_text(const char* text, s16 x, s16 y, u8 font_size, s8 color, s16 rotation, s16 enx, s16 eny);
void display_text_sin(const char* text, s16 x, s16 y, u8 font_size, s8 color, u8 a6);
void display_box_text(display_item_t* box);
void CLRSCR(void);
void display_etoile(s16 in_x, s16 in_y);
void display_grp_stars(void);
void DISPLAY_TEXT_FEE(void);
void display_mini_map(void); // Re-implemented from Rayman Designer
void calculate_link_positions(mem_t* mem); // Re-implemented from Rayman Designer
bool get_link_line(s16 obj_id, s16* out_x1, s16* out_y1, s16* out_x2, s16* out_y2); // Re-implemented from Rayman Designer
void display_obj_links(void); // Re-implemented from Rayman Designer
void DISPLAY_SAVE_SPRITES(s16 x, s16 save_index);
void DISPLAY_SAVE_POING(void);
void DISPLAY_OPTIONS_POING(void);
void DISPLAY_YESNO_POING(void);
void display_time(s16 time);
void DISPLAY_CONTINUE_SPR(void);
void AFFICHE_SPRITE_DEFORME(void* a1, s32 a2, s16 a3, s16 a4, s16 a5, s16 a6, s16 a7, s16 a8, s16 a9, s16 a10);
void DISPLAY_DEFORMATION(obj_t* obj, s16 a2, s16 a3, s16 a4);
void DISPLAY_DEFORM_SPRITE(void* a1, s32 a2, s16 a3, s16 a4, s16 a5, s16 a6, s16 a7);
void CALCUL_DEFORMATION(s16* a1, s16* a2, s16 a3, s16 a4, s16 a5);

// araignee.c
void get_spi_zdc(obj_t* obj, s16* x, s16* y, s16* w, s16* h);
void DO_SPIDER_PLAFOND(obj_t* spipl_obj);
void DO_SPIDER_PLAFOND_POING_COLLISION(obj_t* obj, s16 sprite);
void SPIDER_PLAFOND_REACT(obj_t* obj);
void DO_DARD_PLAFOND_ALWAYS(obj_t* obj);
void DO_SPIDER_COMMAND(obj_t* obj);
void DO_SPIDER_TIR(obj_t* obj);
void allocateDard(obj_t* obj);
void DoSpiderPoingCollision(obj_t* other_obj, s16 sprite);
void DoSpiderRaymanZDD(obj_t* obj);

// audiocd.c
void SetCompteurTrameAudio(void);
void DoCdCredits(void);
void start_cd_credits(void);
void start_cd_ubi_soft(void);
void start_cd_gagne(void);
void start_cd_suspence(void);
void start_cd_gros_rayman(void);
void start_cd_perdu(void);
void DoCdRap(void);
void start_cd_bbdead(void);
void start_cd_gameover(void);
void stop_cd(void);
bool cd_playing(void);

// basic.c
bool EOA(obj_t* obj);
void save_objects_flags(void);
void restore_objects_flags(void);
void snapToSprite(obj_t* obj_1, obj_t* obj_2, u8 obj_2_spr, s32 x_offs, u16 y_offs);
obj_t* findfirstObject(s16 obj_type);
void findfirstInactiveObject(s16 a1);
s32 sinYspeed(obj_t* obj, s16 a2, s16 a3, s16* a4);
void set_proj_center(s16 x, s16 y);
s32 get_proj_dist(s16 scale, s16 outer_dim);
s32 get_proj_dist2(s16 scale, s16 a2);
s32 get_proj_x(s16 scale, s16 a2);
s32 get_proj_y(s16 scale, s16 a2);
void set_zoom_mode(u8 mode);
s32 inverse_proj_x(s16 scale, s16 a2);
s32 inverse_proj_y(s16 scale, s16 a2);
s32 vblToEOA(obj_t* obj, u8 a2);
void GET_ANIM_POS(obj_t* obj, s16* x, s16* y, s16* w, s16* h);
void add_actobj(s16 a1);
void set_sub_etat(obj_t* obj, u8 sub_etat);
void set_main_etat(obj_t* obj, u8 etat);
void set_main_and_sub_etat(obj_t* obj, u8 etat, u8 sub_etat);
s16 get_center_x(obj_t* obj);
s16 get_center_y(obj_t* obj);
u8 on_block_chdir(obj_t* obj, s16 center_x, s16 center_y);
void CALC_FOLLOW_SPRITE_SPEED(obj_t* obj, anim_t* anim_1, anim_t* anim_2, s16 anim_frame_2);
u8 GET_SPRITE_POS(obj_t* obj, s16 index, s16* x, s16* y, s16* w, s16* h);
void GET_RAY_ZDC(obj_t* obj, s16* x, s16* y, s16* w, s16* h);
void GET_BB1_ZDCs(obj_t* obj, s16 *x_1, s16 *y_1, s16 *w_1, s16 *h_1, s16 *x_2, s16 *y_2, s16 *w_2, s16 *h_2);
void calc_obj_dir(obj_t* obj);
u8 OBJ_IN_ZONE(obj_t* obj);
void calc_obj_pos(obj_t* obj);
void makeUturn(obj_t* obj);
u8 BTYP(s32 tile_x, s32 tile_y);
void calc_btyp_square(obj_t* obj);
void DO_OBJ_REBOND_EN_X(obj_t* obj);
u8 calc_btyp(obj_t* obj);
void init_obj_in_the_air(obj_t* obj);
void make_my_fruit_go_down(obj_t* obj, s16 x_accel);
void switchOff(obj_t* obj);
void obj_hurt(obj_t* target);
void Projectil_to_RM(obj_t* obj, s16* out_spd_x, s16* out_spd_y, s16 new_spd_x, s16 new_spd_y);
void del_actobj(obj_t* obj);
s32 calc_let_Width(u8 font_size, s32 num_let);
s32 calc_let_Width2(u8 font_size, s32 num_let);
void INIT_TEXT_TO_DISPLAY(void);
s32 deter_num_let(u8 c, const char* next_chars);
void calc_num_let_spr(u8 a1, u8* a2);
s16 calc_largmax_text(const char* text, s16 char_index, s16 space_width, s16 char_spacing, u8 font_size);
void INIT_TXT_BOX(display_item_t* box);
void Deter_Option_Caract(char* text, s16 key, s16 offset);
void SwapAB(s16* a, s16* b);
void Bresenham(void (*func)(s16, s16), s16 origin_x, s16 origin_y, s16 dest_x, s16 dest_y, s16 param_6, s16 percent);
void init_finBossLevel(void);
void Change_Wait_Anim(void);
void add_alwobj(obj_t* obj);
void del_alwobj(s16 obj_index);
void FatalError(char* message);
u8 sprite_of_ref(obj_t* obj, u8 ref);

// bat.c
void DO_BAT_FLASH(s16 in_x, s16 in_y);
void DO_BAT_LEFT_FLASH(obj_t* obj);
void DO_BAT_RIGHT_FLASH(obj_t* obj);
void DO_BAT_LEFT_RIGHT_FLASH(obj_t* obj);
s16 bat_dir(obj_t* obj);
void DO_BAT_COMMAND(obj_t* obj);
void BAT_ray_in_zone(obj_t* obj);
void DO_BAT_POING_COLLISION(obj_t* bat_obj, s16 sprite);
s32 bat_get_eject_sens(obj_t* obj);

// bbmont.c
void BB2_MARCHE(obj_t* obj);
void DO_TOTEM_TOUCHE(obj_t* obj, s16 sprite);
void DO_TOTEM_COMMAND(obj_t* tot_obj);
void DO_TOTBT_REBOND(obj_t* obj);
void DO_PI_EXPLOSION2(obj_t* obj);
void DO_BBL_REBOND(obj_t* obj);
void allocateDog(obj_t* bb1_obj);
void allocateTir(obj_t* bb1_obj, s16 param_2);
void CreateFirstBBL(void);
void INIT_BBMONT(obj_t* obj);
void DO_BBL_COMMAND(obj_t* obj);
void BBMONT_ECLAIR(obj_t* bb1_obj);
void BBMONT_ETINCELLES(obj_t* in_obj);
void BBMONT_TIRE(obj_t* obj);
void Cree_BBL(obj_t* obj);
void BB_Attaque(obj_t* obj);
void Fin_BB_Attaque(obj_t* obj);
void BB_Atan(obj_t* obj);
void DO_BBMONT_ATTER(obj_t* obj);
void DO_BBMONT_COMMAND(obj_t* obj);
void DO_BBMONT_TOUCHE(obj_t* obj, s16 sprite);
void DO_BBMONT2_COMMAND(obj_t* obj);
void DO_BBMONT2_MARCHE(obj_t* obj);
void DO_BBMONT2_ATTER(obj_t* obj);
void DO_BBMONT3_COMMAND(obj_t* obj);
void DO_BBMONT3_ATTER(obj_t* obj);
void DO_BBMONT4_COMMAND(obj_t* obj);
void DO_ECLAIR_COMMAND(obj_t* ecl_obj);
void DO_BB1_PLAT_CMD(obj_t* obj);

// blacktoon.c
void allocateBlacktoonEyes(obj_t* obj);
void DO_BLK_SPEED_COMMAND(obj_t* obj);
void blkUTurn(obj_t* obj);
void DO_BLK_LR_COMMAND(obj_t* obj);
void DO_BLK_NOP_COMMAND(obj_t* obj);
void DO_BLKTOON_COMMAND(obj_t* obj);
void DoBlackToonPoingCollision(obj_t* obj, s16 sprite);
void DoBlackToonRaymanZDD(obj_t* obj);

// blood.c
void DoEffectBloodOut(void);

// bonus.c
s16 get_allowed_time(void);
void calc_left_time(void);
u8 get_bonus_map_complete(s16 world, s16 lvl);
void set_bonus_map_complete(s16 world, s16 lvl);
void DO_WIZ_AFTER_BONUS_MAP(void);
void init_bonus_perfect(void);
s16 do_perfect_bonus(u32 a1);
void DO_PERFECT_BONUS_MAP(void);

// box.c
void CalcTab(void);
void InitPlasma(u8 need_set_palette);
void Plasma(s16 x, s16 y, s16 width, s16 height, u8 a5, u8 a6, u8 a7, u8 a8, u8 a9, u8 a10, u8 a11, u8 a12, u8 a13);
void PlasmaBox(s16 x, s16 y, s16 width, s16 height, u8 a5);
void InitFire(void);
void Fire(s16 x, s16 y, s16 width, s16 height);
void FireBox(s16 x, s16 y, s16 width, s16 height);
void InitMenuPalette(void);
void CaptureVideo(u8* source_buf, u8* dest_buf, u8 grayscale);
void CadreTrans(s16 x, s16 y, s16 w, s16 h);
void DrawBlackBorderBox(s16 x, s16 y, s16 height, s16 width, u8 a5);
void InitGauge(void);
void gauge(s16 a1, s16 a2, s16 a3, s16 a4, s16 a5, s16 a6, s16 a7);
void ClearBorder(s16 lim_H1, s16 lim_H2, s16 lim_W1, s16 lim_W2);

// blocs.c
u8 MURDUR(s16 x, s16 y);
s32 dist_to_bloc_floor(s16 btype, s16 x, s16 y);
u8 bloc_floor(s16 btype, s16 x, s16 y);
u8 calc_typ_trav(obj_t* obj, u8 a2);
u8 calc_typ_travd(obj_t* obj, u8 a2);
void TEST_FIN_BLOC(obj_t* obj);
u8 TEST_IS_ON_RESSORT_BLOC(obj_t* obj);
u8 IS_ON_RESSORT_BLOC(obj_t* obj);
void CALC_MOV_ON_BLOC(obj_t* obj);
void recale_position(obj_t* obj);
s32 blocs1_empty(s32 x, s32 y);
s32 blocs1_right_45(s32 x, s32 y);
s32 blocs1_left_45(s32 x, s32 y);
s32 blocs1_right1_30(s32 x, s32 y);
s32 blocs1_right2_30(s32 x, s32 y);
s32 blocs1_left1_30(s32 x, s32 y);
s32 blocs1_left2_30(s32 x, s32 y);
s32 blocs3_empty(s32 x, s32 y);
s32 blocs1_liane(s32 x, s32 y);
s32 blocs4_empty(s32 x, s32 y);
s32 blocs1_hor(s32 x, s32 y);
s32 blocs2_empty(s32 x, s32 y);
void init_calcbloc_func(void);

// breakout.c
u8 get_casse_brique_ON(void);
void set_casse_brique_ON(u8 on);
u8 get_casse_brique_active(void);
void set_casse_brique_active(void);
void enter_casse_brique(void);
void enter_casse_brique2(void);
void exit_casse_brique(void);
void exit_casse_brique2(void);
s32 get_speed_ball(void);
void speed_ball_null(obj_t* obj);
void speed_ball_init(obj_t* obj);
void speed_up_ball(obj_t* obj);
void invert_speed_ball_x(obj_t* obj);
void invert_speed_ball_y(obj_t* obj);
void set_ball_pos(obj_t* obj, s16 a2, s16 a3);
void angle_direction(s16 a1, s16 a2);
void move_ball(obj_t* obj);
void get_brik_bonus(void);
void do_bonus(void);
void get_brik_info(obj_t* obj, s16 a2, s16* a3, s16* a4, u8* a5);
void frame_briques(obj_t* obj);
void AllocateCasseBriqueBoum(obj_t* obj);
void AllocateBonus(obj_t* obj, s16 a2, u8 a3, u8 a4);
void bonus_fall(obj_t* obj);
void collision_briques(obj_t* obj);
void collision_rayman(obj_t* obj);
void move_briques(obj_t* obj);
void init_briques(obj_t* obj);
void reset_briques(void);
void casse_brique_init(obj_t* obj);
void casse_brique_start(obj_t* obj);
void ray_face_brik(s16 a1);
void casse_brique_play(obj_t* obj);
void casse_brique_end(obj_t* obj);
void casse_brique_done(obj_t* obj);
void DISPLAY_FIXE_CB(obj_t* obj);
void DO_CB_BALL_COMMAND(obj_t* obj);
void DO_CB_BRIK_COMMAND(obj_t* obj);
void DO_RAY_CASSE_BRIQUE(void);

// cage.c
void DO_CAGE2(obj_t* obj);
void DO_CAGE(obj_t* obj);
void DoCagePoingCollision(obj_t* obj, s16 sprite);
void DO_MEDAILLON_TOON(obj_t* obj);
void DO_MEDAILLON_TOON_GELE(void);
void ALLOCATE_MEDAILLON_TOON(void);
void allocate_toons(obj_t* src_obj, u8 count);
void allocateGrille(obj_t* obj);
void DO_ONE_PINK_CMD(obj_t* obj);
void DoLidolPinkRaymanZDD(obj_t* obj);

// clown.c
void DO_CLOWN_TNT_COMMAND(obj_t* obj);
void DO_CLOWN_TNT2_COMMAND(obj_t* obj);
void DO_CLOWN_TNT3_COMMAND(obj_t* obj);
void DO_BIG_CLOWN_ATTAK(obj_t* obj);
void allocatedrop(obj_t* obj);
void DO_WAT_CLOWN_ATTAK(obj_t* obj);
void DO_CLOWN_TNT_ATTACK(obj_t* obj);
void Clown_Music_Atter(obj_t* obj);
void DoWatAndBigClownPoingCollision(obj_t* obj, s16 sprite);
void DoTntClownPoingCollision(obj_t* obj, s16 sprite);
void DoWatAndBigClownRaymanZDD(obj_t* obj);
void DoTntClownRaymanZDD(obj_t* obj);

// collision.c
s32 get_nb_zdc(obj_t* obj);
s32 get_zdc_index(obj_t* obj);
zdc_t* get_zdc(obj_t* obj, s32 a2);
u16 get_ZDCPTR(void);
s32 in_coll_sprite_list(obj_t* obj, s16 a2);
bool box_inter_v_line(s16 a1, s16 a2, s16 a3, s16 a4, s16 a5, s16 a6, s16 a7);
bool box_inter_h_line(s16 a1, s16 a2, s16 a3, s16 a4, s16 a5, s16 a6, s16 a7);
s16 inter_box(s32 x_1, s32 y_1, s32 w_1, s32 h_1, s16 x_2, s16 y_2, s32 w_2, s32 h_2);
void GET_OBJ_ZDC(obj_t* obj, s16 *out_x, s16 *out_y, s16 *out_w, s16 *out_h);
s16 GET_SPRITE_ZDC(obj_t* obj, s16 index, s16 *out_x, s16 *out_y, s16 *out_w, s16 *out_h);
s32 BOX_HIT_SPECIAL_ZDC(s16 in_x, s16 in_y, s16 in_w, s16 in_h, obj_t* obj);
s32 BOX_IN_COLL_ZONES(s16 type, s16 x, s16 y, s16 w, s16 h, obj_t* obj);
s32 COLL_BOX_SPRITE(s16 x, s16 y, s16 w, s16 h, obj_t* obj);
s16 CHECK_BOX_COLLISION(s16 type, s16 x, s16 y, s16 w, s16 h, obj_t* obj);
s16 possible_sprite(obj_t* obj, s16 index);
s16 setToleranceDist(s16 x, s16 w, s16 y);
void SET_RAY_DIST_SLOPEY_PLAT(obj_t* obj);
void SET_RAY_DIST_MULTISPR_CANTCHANGE(obj_t* obj);
void SET_RAY_DIST_PI(obj_t* obj);
void SET_RAY_DIST_BAG(obj_t* obj);
void SET_RAY_DIST(obj_t* obj);
void do_boum(void);
void DO_POING_COLLISION(void);
void DoPoingCollisionDefault(obj_t* obj, s16 sprite);
void COLL_BOX_ALL_SPRITES(s16 a1, s16 a2, s16 a3, s16 a4, obj_t* obj);
bool COLL_RAY_PIC(void);
void COLL_RAY_BLK_MORTEL(void);
void RAY_KO(void);
void RAY_HIT(bool hurt, obj_t* obj);
void standard_frontZone(obj_t* obj, s16* x, s16* w);
void SET_DETECT_ZONE_FLAG(obj_t* obj);
void goToRay(obj_t* obj);
void unleashMonsterHost(obj_t* obj);
void SHOW_COLLISIONS_ZONES(void);
void DO_COLLISIONS(void);
void DoRaymanCollisionDefault(obj_t* obj);
void DO_OBJ_COLLISIONS(obj_t* obj, s16 offs);
u8 test_allowed(obj_t* obj, s16 center_x, s16 center_y);
void obj_jump(obj_t* obj);
void DO_MOVING_PLATFORM_COMMAND(obj_t* obj);
void DoPTGRAPPINPoingCollision(obj_t* obj, s16 sprite);
void DO_ONE_CMD_WAIT(obj_t* obj); // TODO: maybe make a split here: command.c?
void DO_ONE_CMD_LR_ATTENTE(obj_t* obj);
void DO_ONE_CMD_UPDOWN(obj_t* obj);
void special_pour_liv(obj_t* event);
void DO_ONE_CMD(obj_t* obj);
void DO_ROLL_EYES(obj_t* obj);
void DoKillingEyesPoingCollision(obj_t* obj, s16 sprite);
void YaUnBloc(obj_t* obj);
void DO_BAG1_COMMAND(obj_t* obj);
void DoRaymanBag1Collision(obj_t* obj);
s16 MarCoince(obj_t* obj, s16 dir);
void DO_MOVE_MARACAS_COMMAND(obj_t* obj);
void DO_FLASH_COMMAND(obj_t* obj);
void DO_WLKNOT_COMMAND(obj_t* obj);
void ACTIVE_L_EAU(obj_t* eau_obj);
void DO_EAU_QUI_MONTE(obj_t* obj);
void allocateOtherPosts(obj_t* her_bh_obj);
void doHerseCommand(obj_t* obj);
void doBlackRaymanCommand(obj_t* obj);
void doBlKRayRaymanCollision(obj_t* obj);
void DO_POELLE_COMMAND(obj_t* po_obj);
void DO_CORDE_COMMAND(obj_t* obj);
void DO_PAC_COMMAND(obj_t* obj);
void DO_CFUMEE_COMMAND(obj_t* obj);
void DO_NOVA2_COMMAND(obj_t* obj);
void doShipCommand(obj_t* obj);
void DO_PROP_COMMAND(obj_t* obj);
void move_fruit_in_water(obj_t* obj);
void DO_FALLING_OBJ_CMD(obj_t* obj);
void DoFallingObjPoingCollision(obj_t* obj, s16 sprite);
void DO_BLKTOON_EYES_CMD(obj_t* obj);
void DO_RAY_POS_CMD(obj_t* obj);

// compress.c
// (todo)

// cymbal.c
void DO_CYMBAL_COMMAND(obj_t* obj);
void DO_2_PARTS_CYMBAL(obj_t* cym_obj);
void DO_COLL_RAY_CYMBALE(obj_t* cym_obj);

// dark.c
void PlaceDarkPhase1et2(obj_t* obj);
void dark_attaque_suivante(obj_t* obj);
void init_vitraux(void);
void poing_face_obj(obj_t* obj);
void DARK_phase1(obj_t* obj);
void DARK_phase3(obj_t* obj);
void DO_DARK_COMMAND(obj_t* obj);
void DO_DARK_POING_COLLISION(obj_t* obj, s16 sprite);
void DO_DARK_REACT(obj_t* obj);
void DO_DARK_SORT_COMMAND(obj_t* obj);
void DO_DARK_SORT_COLLISION(obj_t* obj);
void allocate_DARK_SORT(obj_t* obj);
void DoAnnuleDarkSortRaymanCollision(obj_t* obj);
void corde_en_bas(obj_t* obj);
void corde_en_haut(obj_t* obj);
void init_corde(obj_t* obj);
void goto_phase1(obj_t* obj);
void goto_phase2(obj_t* obj);
void goto_phase3(obj_t* obj);
void goto_phase5(obj_t* obj);
void DO_VITRAIL_COMMAND(obj_t* obj);
void allume_vitraux(obj_t* obj);

// display.c
s16 display_inter_anim(u32 a1);
void continue_fonction(void);
void DO_CONTINUE(void);
s16 saisie_nom_prg(u32 a1);
s16 selection_save_option_prg(u32 a1);
void DO_SAVE_CHOICE(void);
void AFFICHE_ECRAN_SAVE(void);
s16 select_level_prg(u32 a1);
s16 SELECT_LEVEL(s16 original_level_choice);
void CLEAR_STAGE_NAMES(void);
void DISPLAY_STAGE_NAMES(void);
s16 WORLD_CHOICE(u32 a1);
void DO_WORLD_MAP(void);
void DISPLAY_TXT_VIGNET(void);
s16 display_vignet_prg(u32 a1);
void DISPLAY_GAME_VIGNET(void);
void DISPLAY_TXT_CREDITS(void);
s16 display_credits_prg(u32 a1);
void display_anim_victoire(void);
void DISPLAY_CREDITS(void);
void DISPLAY_CREDITS_MENU(void);
void DISPLAY_PROTOON_BACK(void);
void DO_ANIM_VICTOIRE(void);
void DO_VICTOIRE(void);
void InitDemoJeu(void);
void FinDemoJeu(void);
s16 loader_anim_prg(u32 a1);
void START_LOADER_ANIM(void);
void END_LOADER_ANIM(void);
void DO_GROS_RAYMAN(void);
void START_LEVEL_ANIM(void);
void PouvoirsParMap(void);
void sub_35F70(void);
void sub_3609C(void);
void sub_36150(void);
void FIRST_INIT(void);
void init_divers_level_PC(u8* a1);
void file_level(s32 level_id, char* filename);
void world_level(s32 world_id, char* filename);
void LoadPlan3InVignet(mem_t* mem, s32 resource_id);
void DISPLAY_AND_FADE_PLAN3(void);
void LOAD_VIGNET_PC(mem_t* mem, s16 world);
void LOAD_SAVE_SCREEN(mem_t* mem);
void LOAD_PERFTIME_SCREEN(mem_t* mem);
void LOAD_PERFECT_SCREEN(mem_t* mem);
void LOAD_CONTINUE_SCREEN(mem_t* mem);
void DISPLAY_FOND_CONTINUE(void);
void SwapPlan2PlanVignInVignet(mem_t* mem, s32 resource_id, s16 vig_index);
void LOAD_VIGNET_GAME(mem_t* mem);
void LOAD_CREDITS_VIGNET(s32 a1, s32 a2, s16 a3);
void DEPART_WORLD(void);
void DEPART_LEVEL(void);
void REMOVE_FICHIER(void);
s32 TestSave(void);
void test_EXIT(void);
void test_Keyb_on_wldmap(void);
void Keyflush(void);
void LOAD_GENERAL_SCREEN(void);
void LOAD_OPTIONS_SCREEN(void);
void HANDLE_KEY(u8* a1);
void DEPART_INIT_LOOP(void);
void DEPART_DEAD_LOOP(void);
void FIN_GAME_LOOP(void);
void FIN_MAP_LOOP(void);
void FIN_DEAD_LOOP(void);
void END_GAME(void);
void INIT_EXTENSIONS(void);
void DISPLAY_LOADING(void);
void START_WORLD_VIGNET(void);
void END_WORLD_VIGNET(void);
void sub_36FAC(void);
void sub_36FBB(void);
void sub_370E8(void);
void sub_37134(void);
bool LOAD_BIG_RAYMAN(mem_t* mem);
bool ValidButPressed(void);
bool StartButPressed(void);
bool PauseButPressed(void);
bool ExitButPressed(void);
bool CancelButPressed(void);
bool SelectButPressed(void);
void ToDoAtExit(void);

// cheat.c
void PC_clear_text_input_buffer(void);
void PC_init_cheats(void);
void PC_do_cheats_in_world_map(void);
void PC_do_cheats(void);
void rayverse_do_debug_cheats(void);

// effect.c
void sub_37B90(void);
void sub_37C00(void);
void sub_37C40(void);
void sub_37C98(void);
void sub_37CDC(void);
void sub_37D4C(void);
void sub_37D90(void);
void sub_37E00(void);
void sub_37E44(void);
void sub_37E9C(void);
void sub_37EE0(void);
void sub_37F50(void);
void sub_37F94(void);
void sub_37FEC(void);
void sub_38030(void);
void sub_38054(void);
void sub_38064(void);
void sub_38074(void);
void sub_380A4(void);
u8 sub_38208(s32 a1, s32 a2, u8* a3, u8* a4);
u8 sub_38220(s32 a1, s32 a2, u8* a3, u8* a4);
void sub_38258(void);
void sub_38290(void);
void SaveScreen(u8* a1, u8* a2);
void RestoreScreen(u8* a1, u8* a2);
void DO_AFFICHE_PAUSE(void);
s16 dummy_prg(u32 a1);
void Do_Effect_Pause_Simple(void);
void Do_Effect_Pause_unknown(void);
void Do_Effect_Pause(void);
void sub_38A30(void);
void sub_38B58(void);
void sub_38DA0(void);
void sub_38DCC(void);
void sub_38ED4(void);
void sub_391C0(void);

// fee.c
void INIT_TXT_FEE(void);
void allocate_poing_or_free(void);
void init_fee(void);
void wait_for_dialogue_fee(obj_t* obj, s16 time);
void DO_FEE_ETAPE(obj_t* obj);
void fee_gives_super_evts(void);
void DO_FEE(obj_t* obj);
void DoFeeRaymanZDD(obj_t* obj);

// frame.c
void display_movie_frames(void);
s32 playVideo2(const char* path, const char* filename, s32 a3, u8 a4);
s32 playVideo(const char* path, const char* filename, s32 a3);
s32 playVideo_alt(const char* path, const char* filename, s32 a3);
void SWAP_BUFFERS(void);
void sub_3B580(void);
void sub_3B5E8(void);
void calc_gros_type(void);
void find_in_map(s16 a1, s16 a2);
void init_find_in_map(void);
void end_find_in_map(void);
void build_map(s16 a1, s16 a2);
void build_line_map(void* a1, s16 a2, s16 a3, s16 a4);
void build_column_map(void* a1, s16 a2, s16 a3, s16 a4);
void update_map(s16 a1, s16 a2, s16 a3, s16 a4);
void sub_3BE20(void);
void sub_3BEE0(s16 a1, s16 a2);
void set_vga_frequency(u8 freq);
void GetVideoRegister(void);
void SetVideoRegister(void);
void sub_3C3BC(void);
void clear_palette(rgb_palette_t* palette);
void set_fade_palette(rgb_palette_t* palette);
void start_fade_in(s16 speed);
void start_fade_out(s16 speed);
void do_fade(rgb_palette_t* source_pal, rgb_palette_t* dest_pal);
void fade_out(s16 speed, rgb_palette_t* palette);
void actualize_palette(u8 new_pal_id);
void cyclage_palette(s16 a1, s16 a2, s16 a3);
void DO_SWAP_PALETTE(void);
void DO_FADE(void);
void INIT_FADE_IN(void);
void INIT_FADE_OUT(void);
void DO_FADE_OUT(void);
void EFFACE_VIDEO(void);
void SYNCHRO_LOOP(scene_func_t scene_func);
void DISPLAY_ANYSIZE_PICTURE(void* a1, s16 a2, s16 a3, s16 a4, s16 a5, s16 a6, s16 a7);
void SAVE_PALETTE(rgb_palette_t* palette);
void RESTORE_PALETTE(void);
void SAVE_PLAN3(void);
void RESTORE_PLAN3(void);
void DISPLAY_FOND3(void);
void DISPLAY_FOND_MENU(void);
void InitPaletteSpecialPC(void);
void DoFadePaletteSpecialPC(s16 a1, s16 a2);
void DoPaletteSpecialPC(void);
void InitModeXWithFrequency(u8 freq);
void InitTextMode(void);
void InitModeNormalWithFrequency(u8 freq);
void WaitNSynchro(s32 n_frames);

// guetteur.c
void swapGuetteurCollZones(obj_t* obj, u8 param_2);
void guetteurFollowsShip(obj_t* obj);
void DO_ONE_PAR_COMMAND(obj_t* obj);
s32 hasGuetteurABomb(obj_t* obj, s32 param_2);
void allocatePirateGuetteurBomb(obj_t* gue_obj, s32 param_2, u8 param_3, u8 param_4);
void DO_PAR_TIR(obj_t* obj);
void DO_PAR_POING_COLLISION(obj_t* obj, s16 sprite);
void PAR_REACT_TO_RAY_IN_ZONE(obj_t* obj);
void DO_PAR_BOMB_COMMAND(obj_t* obj);

// hifi.c
void sub_3E66C(void);
void sub_3E6B0(void);
void rayman_sound_fatal_error(const char* message);
void sub_3E710(void);
void sub_3E780(void);
void LoadBnkFile(s32 header_index, s32 data_index, bnk_header_t* headers, u8** data);
void LoadBnkFile_debug(s32 sound_set, s32 a2, u8** sound_buffer);
void LoadBnkFixe(void);
void LoadBnkWorld(s16 world);
s16 KeyOn(u8 bank, u8 prog, u8 tone, u8 note, u8 volume, u8 pan);
void KeyOff(u32 voice_id, u8 bank, u8 prog, u8 tone, u8 note);
void KeyVol(s32 voice_id, s32 volume, s32 pan);
void DigiMusicDone(void);
void LoadTchatchPerdu(void);
void PlayTchatch(s32 snd, s32 volume);
void FreeTchatchVignette(void);
void SetPort_(s32 port); // NOTE: extra underscore added because SetPort is also used by the Win32 API (in winspool.h)
void SetIrq(s32 irq);
void SetDma(s32 dma);
void SetParam(s32 param);
void SetDeviceID(s32 device_id);
char* GetDeviceName(void);
s32 GetPort(void);
s32 GetIrq(void);
s32 GetDma(void);
s32 GetParam(void);
s32 GetDeviceID_Ray(void);
void FreeDetectDriver(void);

// hybrid.c
void allocateSTOSKO(void);
void allocateMOSKITOMAMA(obj_t* obj);
void allocateMOSKITOSAXO(obj_t* obj);
void doMOSAMScommand(obj_t* obj);
void DoMOSAMSPoingCollision(obj_t* obj, s16 sprite);
void allocateStoskoClaw(obj_t* obj);
void doSTOSKOcommand(obj_t* obj);
void DoSTOSKOPoingCollision(obj_t* obj, s16 sprite);
void doBBF2command(obj_t* obj);
void DO_HYB_BBF2_POING_COLLISION(obj_t* obj, s16 sprite);
void AllocateTirBBF2(obj_t* obj);
void DO_HYB_BBF2_LAS(obj_t* obj);
void DoHybBBF2LasRaymanCollision(obj_t* obj);
void OBJ_IN_COL_ZDC(obj_t* obj1, obj_t* obj2);
void AllocateDarkPhase2(obj_t* obj);
void DO_DARK2_AFFICHE_TEXT(void);
void DO_DARK_PHASE2_COMMAND(obj_t* obj);
void DO_DARK2_SORT_COMMAND(obj_t* obj);
void allocate_DARK2_SORT(obj_t* obj);
void DoFlammeCommand(obj_t* obj);
void DoFlammeRaymanCollision(obj_t* obj);
void AllocateFlammes(s16 a1);
void AllocateToons(void);
void DO_DARK2_TOONS_COMMAND(obj_t* obj);
void ToonDonnePoing(obj_t* obj);

// input.c
void POINTEUR_BOUTONS_OPTIONS_BIS(void);
u8 TestKeyWeapon(void);
u8 TOUCHE(u8 key);
u8 TestKeyJump(void);
u8 TestKeyAction(void);
s32 leftjoy(void);
s32 rightjoy(void);
s32 downjoy(void);
s32 upjoy(void);
s32 but0pressed(void);
s32 but1pressed(void);
s32 but2pressed(void);
s32 but3pressed(void);
s32 butX0pressed(void);
s32 butX1pressed(void);
void sub_4212C(s16 a1);
void readinput(void);
void readinput_calibrate_joystick(void);
void readinput_center_joystick(void);
void update_pad_limits(s16* xmax, s16* xmin, s16* ymax, s16* ymin, s16* xcentre, s16* ycentre);
void sub_4225C(void);
void read_record(const char* filename);
void load_record(void);
void sub_42408(u8 a1);
void do_record(record_t* rec);
void PC_keyboard_interrupt_handler(u8 scancode);
void sub_425AB(void);
void RESET_TOUCHE(u8 key);
void RESET_ALL_TOUCHE(void);
void Init_Clavier(void);
void Reset_Clavier(void);
bool JoystickPresent(void);

// jumelle.c
void plot2linejumelle(s32 jumelle_x, s32 jumelle_y, s32 plot_x, s32 plot_y, s32 circle2_offset, u8* effet_buf, u8* draw_buf);
void DisplayJumellesNormal(s32 x, s32 y, s32 rayon, s32 a4, u8* effet_buf, u8* draw_buf);
void InitMatriceJumelle(void);
void DefaultJumelleVariable(void);
void ChangeDeltaSizeJumelle(s32 delta_size);
void CalculVitesseJumelle(void);
void ChangeDeltaPosXJumelleWithoutLimit(s32 delta_pos_x);
void ChangeDeltaPosYJumelleWithoutLimit(s32 delta_pos_y);
s32 ChangeDeltaPosXJumelleWithLimit(s32 delta_pos_x);
s32 ChangeDeltaPosYJumelleWithLimit(s32 delta_pos_y);
void ChangeJumelleVariable(void);
void ChangeDeltaZoomAmpJumelle(s32 a1);
void PrepareJumelleZoom(void);
void RecaleRayPosInJumelle(void);
void DisplayJumellesFondNormal(void);
void DoScrollInWorldMap(s16 h_speed, s16 v_speed);
void CalcObjPosInWorldMap(obj_t* obj);
void MoveRayInWorldMap(void);

// load.c
void load_world(mem_t* mem_world, mem_t* mem_sprite, const char* filename);
void load_level(mem_t* mem_level, s32 world_id, const char* filename);
void load_big_ray(mem_t* buffer);
void LOAD_ALL_FIX(void);
image_t LoadPcxInVignet(mem_t* buffer, s32 resource_id, s16* width, s16* height, rgb_palette_t* pal_to_save);
void LoadPcxPaletteInVignet(s32 resource_id, rgb_palette_t* palette);
void LoadPlan0InVignet(s32 resource_id);
u8* allocate_PLAN0(mem_t* mem_world, s32 width, s32 height);
void PLAN0FND_to_bits_planes(u8* buffer, s16 width, s16 height);
void LoadPlan2InVignet(mem_t* buffer, s32 resource_id);
char* GetStringTxt(char* txt, char* out_buf);
void LoadLanguageTxt(mem_t* mem, s32 language_index);
void LoadPcxOptions(u8* buffer, s32 resource_id, s16* width, s16* height, rgb_palette_t* pal_to_save);

// luciole.c
void get_luciole(void);
void CLEAR_FIXE_LUCIOLE(void);
void set_luciole(s32 a1, s32 a2);
void init_aff_luciole(s32 a1, s32 a2);
void plot2line(s32 a1, s32 a2, s32 a3, s32 a4, s32 a5);
void aff_luciole(s32 a1, s32 a2, s32 a3, s32 a4);
void Display_and_free_luciole(u8* draw_buf);
void free_luciole(void);
void INIT_LUCIOLE(void);
void DO_LUCIOLE(void);

// menu.c
void LOAD_FND(void);
void INIT_FND(void);
void calc_off_fnd(void);
void check_key_table(void);
void LOAD_CONFIG(void);
void NewFrequency(u8 new_frequency);
void InitClipping(void);
bool IsBackgroundOn(void);
void init_key2txt(void);
void DO_NEW_MENUS(void);
void DO_OPTIONS_IN_GAME(void);
void INIT_GENERAL_CHOICE(void);
void AFFICHE_ECRAN_GENERAL(void);
void DO_COMMANDE_GENERAL(void);
void END_GENERAL_SCREEN(void);
void INIT_OPTIONS_CHOICE(void);
void INIT_AFFICHE_ECRAN_OPTIONS(void);
void AFFICHE_ECRAN_OPTIONS(void);
void DO_COMMANDE_OPTIONS(void);
void END_OPTIONS_SCREEN(void);
void INIT_KEY_SCREEN(void);
void INIT_AFFICHE_KEY_SCREEN(void);
void AFFICHE_KEY_SCREEN(void);
void DO_COMMANDE_KEY(void);
void END_KEY_SCREEN(void);
void INIT_BUTTON_SCREEN(void);
void INIT_AFFICHE_BUTTON_SCREEN(void);
void AFFICHE_BUTTON_JOYSTICK(void);
void DO_BUTTON_COMMANDE(void);
void END_BUTTON_COMMAND(void);
void INIT_PAD_SCREEN(void);
void INIT_AFFICHE_PAD_SCREEN(void);
void AFFICHE_PAD_SCREEN(void);
void DO_COMMANDE_PAD(void);
void END_PAD_SCREEN(void);
void InitParamGraphicsScreen(void);
void INIT_GRAPHIC_SCREEN(void);
void INIT_AFFICHE_GRAPHIC_SCREEN(void);
void AFFICHE_GRAPHIC_SCREEN(void);
void DO_COMMANDE_GRAPHIC(void);
void END_GRAPHIC_SCREEN(void);
void INIT_VIDEOMODE_SCREEN(void);
void INIT_AFFICHE_VIDEOMODE_SCREEN(void);
void AFFICHE_VIDEOMODE_SCREEN(void);
void DO_COMMANDE_VIDEOMODE(void);
void END_VIDEOMODE_SCREEN(void);
void INIT_CALIBRATE_JOYSTICK(void);
void AFFICHE_CALIBRATE_JOYSTICK(void);
void calibrate_joystick_prg(void);
void AFFICHE_CENTER_JOYSTICK(void);
void center_joystick_prg(void);
void MAIN_CALIBRATE_JOYSTICK(void);
s16 menu_prg(u32 a1);
void DO_INTER_MENU(void);
void DO_MENU(void);
void default_key(void);
void new_key(void);
s32 CalcSpeed(void);
void general_init_screen(s16 a1, s16 a2, s16 a3);
void TestCompteur(void);
void TestButtonReleased(void);
void display_box_text_plasma(display_item_t* box, u8 a2);
void display_box_text_fire(display_item_t* a1);
s16 display_box_msg_prg(u32 a1);
void display_box_msg(display_item_t* box);
void display_box_msg_commande(display_item_t* box, void_func_t commande_box_func);
void AfficheYesNo(void);
void DO_YESNOBIS(void);
u8 confirmation_msg(u8 which_message);
void SYNCHRO_LOOP_PALETTE(void* func);
void apparition_prg(void);
void fondu_prg(void);
void change_couleur_prg(void);
void FonduOption(s16 x, s16 y, s16 w, s16 h, u8 a5);
s16 FonduPixel_prg(u32 a1);
void FonduPixel(s16 x, s16 y, s16 w, s16 h);

// meredenis.c
u8 mereDenisCanAttak(obj_t* obj);
void setMereDenisAtScrollBorder(obj_t* obj, u8 flip_x);
void setCirclePointToReach(obj_t* obj);
void allocateMereDenisBombChips(obj_t* obj);
void mereDenisExplodeBombs(obj_t* obj);
void mereDenisDropBomb(obj_t* obj);
void swapWeaponAnimState(obj_t* obj, u8 new_sub_etat);
void swapMereDenisCollZones(obj_t* obj, u8 a2);
void prepareNewMereDenisAttack(obj_t* obj);
void snapLaserToWeapon(obj_t* obj, u8 param_2);
void allocateSpaceMamaLaser(obj_t* obj);
void doMereDenisCommand(obj_t* obj);
void changeMereDenisPhase(obj_t* obj);
void fitSaveCurrentAction(obj_t* obj);
void doMereDenisHit(obj_t* obj, s16 sprite);
void mereDenisBigLaserCommand(obj_t* obj);
void mereDenisBombCommand(obj_t* obj);


// mite.c
void mite_esquive_poing(obj_t* mit_obj, s16* out_diff_x);
u8 HAS_MIT_JUMP(obj_t* obj);
u8 ray_over_mit(obj_t* obj, s16 a2);
void fix_mit_Xspeed(obj_t* obj, s16 a2);
void DO_MIT_ATTAK(obj_t* obj);
u8 IS_MIT_PAF(obj_t* obj);
void DO_MIT_COMMAND(obj_t* obj);
void DoMitePoingCollision(obj_t* obj, s16 sprite);
void DO_MITE2_COMMAND(obj_t* obj);
void DoMite2PoingCollision(obj_t* obj, s16 sprite);
void DO_MITE2_ESQUIVE(obj_t* mit2_obj);

// moskito.c
void getIdealStingCoords(obj_t* obj, s16* out_x, s16* out_y);
u8 closeEnoughToSting(obj_t* obj, s16 min_x, s16 min_y);
u8 moskitoCanAttak(obj_t* obj);
s16 setMoskitoAtScrollBorder(obj_t* obj, u8 a2);
void prepareNewMoskitoAttack(obj_t* mst_obj);
obj_t* allocateMoskitoFruit(obj_t* mst2_obj);
void moskitoDropFruitOnRay(obj_t* obj);
void doMoskitoCommand(obj_t* obj);
u8 tellNextMoskitoAction(obj_t* obj);
void changeMoskitoPhase(obj_t* obj);
void doMoskitoHit(obj_t* obj, s16 sprite);
void DO_MST_SCROLL_COMMAND(obj_t* obj);
void DO_MST_CHANGE_COMMAND(obj_t* obj);
void DoMstShakyFruitRaymanZDD(obj_t* obj);

// moteur.c
void INIT_HORLOGES(void);
void horloges(u8 ticks);
void init_allowed_time(void);
void fades(void);
s16 frapsol(s16 a1);
void DO_SCREEN_TREMBLE(void);
void DO_SCREEN_TREMBLE3(void);
void DO_SCREEN_TREMBLE2(void);
void DO_SCROLL(s16* h_speed, s16* v_speed);
void allocateLandingSmoke(obj_t* in_obj);
s32 instantSpeed(s16 speed);
void SET_X_SPEED(obj_t* obj);
void make_active2(obj_t* obj, u8 do_nova);
void make_active(obj_t* obj, u8 do_nova);
bool in_action_zone(s16 screen_x, s16 screen_y, obj_t* obj, u8 active);
void kill_obj(obj_t* obj);
void SET_ACTIVE_FLAG(s16 screen_x, s16 screen_y, obj_t* obj);
s32 DO_PESANTEUR(obj_t* obj);
void freezeAnim(obj_t* obj, u8 a2);
void DO_ANIM(obj_t* obj);
s16 prof_in_bloc(obj_t* obj);
void do_boing(obj_t* obj, u8 main_etat, u8 sub_etat);
u8 underSlope(obj_t* obj);
void DO_STONEBOMB_REBOND(obj_t* obj);
void DO_THROWN_BOMB_REBOND(obj_t* obj, s16 pesanteur, s16 a3);
void DO_FRUIT_REBOND(obj_t* obj, s16 pesanteur, s16 a3);
void Drop_Atter(obj_t* obj);
void BadGuyAtter(obj_t* obj);
void MiteAtter(obj_t* obj);
void LidolPinkAtter(obj_t* obj);
void stoneDogAtter(obj_t* obj);
void stoneDogBounces(obj_t* obj);
void Spider_Atter(obj_t* obj);
void NormalAtter(obj_t* obj);
void OBJ_IN_THE_AIR(obj_t* obj);
void test_fall_in_water(obj_t* obj);
void MOVE_OBJECT(obj_t* obj);
void DO_RAY_IN_ZONE(obj_t* obj);
void DoRaymanInZDDDefault(obj_t* obj);
void DO_ONE_OBJECT(obj_t* obj);
void build_active_table(void);
void Add_One_RAY_lives(void);
void DO_CLING_ANIMS(void);
void DO_OBJECTS_ANIMS(void);
void DO_OBJECTS(void);
void MOVE_OBJECTS(void);
void RECALE_ALL_OBJECTS(void);
u8 RayCoince(s16 dir);
void move_up_ray(void);
void move_down_ray(void);
void recale_ray_pos(void);
void RAY_TO_THE_RIGHT(void);
void RAY_TO_THE_LEFT(void);
void DO_FIXE(void);
void deactivate_ship_links(void);
u8 linkListHoldsAGendoor(obj_t* obj);
void correct_gendoor_link(u8 a1);
void suppressFromLinkList(obj_t* obj);
void correct_link(void);
void INIT_RAY_BEGIN(void);
void INIT_RAY(u8 new_lvl);
u8 is_icy_pente(u8 btyp);
void STOPPE_RAY_EN_XY(void);
void DO_PLACE_RAY(void);
void DO_AUTO_SCROLL(void);
void INIT_MOTEUR(u8 new_lvl);
void INIT_MOTEUR_BEGIN(void);
void INIT_MOTEUR_WORLD(void);
void INIT_MOTEUR_LEVEL(s16 a1);
void restore_gendoor_link(void);
void DONE_MOTEUR_LEVEL(void);
void INIT_MOTEUR_DEAD(void);
void INIT_RAY_ON_MS(void);
void DO_MOTEUR(void);
void DO_MOTEUR2(void);
void RAY_REVERSE_COMMANDS(void);
void RAY_DEMIRAY(void);
void Ray_RayEcrase(void);
void DO_MOTEUR_GELE(void);

// neige.c
void DoFirstFlocons(void);
void add_one_floc(void);
void add_256_flocs(void);
void sub_one_floc(void);
void init_flocons(void);
void do_flocons(s16 x, s16 y, s16 x_old, s16 y_old);
void set_snow_sequence(s16 seq, s16 len);
void set_SNSEQ_list(s16 a1);
void DO_SNOW_SEQUENCE(void);
void DoNeigeRaymanCollision(obj_t* obj);

// map.c
void deter_vide_plein_panach(void* a1, s16 a2);
void deter_nb_blocks(void* a1, s16 a2, s16 a3, s32* a4, s32* a5);
void Copy_Blocks(mem_t* buffer, void* a2, s16 a3, s16 a4);
void construct_MAP(mem_t* mem, big_map_t* big_map, void* map_blocks);
void init_build_map(big_map_t* a1);
void update_display_map(big_map_t* a1);
void set_default_Bloc_clipping(void);
void set_xymapini(void);
void set_xymap(void);
void set_whmap(s32 a1, s32 a2, void* a3);
void recaleRaysurlesBords(void);
void set_xywhmap(s16 xmin, s16 xmax, s16 ymin, s16 ymax);
void MaskScrollDiffSprites(mem_t* buffer);
void DRAW_MAP(u8* draw_buf, big_map_t* big_map);
void INIT_GAME_MODE_NORMAL(void);
void FIN_GAME_MODE_NORMAL(void);

// ngawe.c
void ngaweFollowsShip(obj_t* obj);
void ngaweTriesToGrabShip(obj_t* obj);
void allocatePirateNgaweRing(obj_t* ngw_obj, s16 spd_y, u8 param_3);
void DO_NGW_TIR(obj_t* obj);
void NGW_REACT_TO_RAY_IN_ZONE(obj_t* obj);
void DO_ONE_NGW_COMMAND(obj_t* obj);
void DO_NGW_POING_COLLISION(obj_t* ngw_obj, s16 sprite);
void DO_ONE_NGW_RING_COMMAND(obj_t* ring_obj);

// mathutil.c
void set2bits(u32 * x, u8 index, u32 value);
u32 read2bits(u32* x, u8 index, u32* high_bit, u32* low_bit);
void setbit(u8 *buffer, u16 index);
void clearbit(u8 *buffer, u16 index);
u8 getbit(u8 *buffer, u16 index);
s32 reflexion(s32 a1, s32 a2);
s32 ashl16(s16 x, u8 bits);
s16 ashr16(s16 x, u8 bits);
s32 ashl32(s32 x, u8 bits);
s32 ashr32(s32 x, u8 bits);
s32 sgn(s32 x);
s32 cosinus(s32 x);
s32 sinus(s32 x);
void sinus_cosinus(s32 x, s16 *cosinus_result, s16 *sinus_result);
s32 abs_sinus(s32 x);
s32 abs_cosinus(s32 x);
void abs_sinus_cosinus(s32 x, s16 *sinus_result, s16 *cosinus_result);

// objinit.c
u8 Prio(obj_t* obj);
void first_obj_init(obj_t* obj);
void obj_init(obj_t* obj);
void init_struct_level(void);
void INIT_OBJECTS(u8 a1);
void REINIT_OBJECT(obj_t* obj);
void special_flags_init(void);

// objupdate.c
void popCmdContext(obj_t* obj);
s16 char2short(u8 x);
u8 readNoArg(obj_t* obj);
u8 skipNoArg(obj_t* obj);
u8 readOneArg(obj_t* obj);
u8 readTestArgs(obj_t* obj);
u8 readGoXYargs(obj_t* obj);
u8 readSpeedArgs(obj_t* obj);
u8 readInvalidArg(obj_t* obj);
u8 skipOneArg(obj_t* obj);
u8 skipTestArgs(obj_t* obj);
u8 skipGoXYArgs(obj_t* obj);
u8 skipSpeedArgs(obj_t* obj);
u8 handle_SELF_HANDLED(obj_t* obj);
u8 skipInvalidArg(obj_t* obj);
u8 handle_11_GO_LABEL(obj_t* obj);
u8 handle_19_GO_WAITSTATE(obj_t* obj);
u8 handle_25_RESERVED_GO_GOSUB(obj_t* obj);
u8 handle_RESERVED_GO_SKIP_and_RESERVED_GO_GOTO(obj_t* obj);
u8 handle_26_RESERVED_GO_BRANCHTRUE(obj_t* obj);
u8 handle_27_RESERVED_GO_BRANCHFALSE(obj_t* obj);
u8 handle_28_RESERVED_GO_SKIPTRUE(obj_t* obj);
u8 handle_29_RESERVED_GO_SKIPFALSE(obj_t* obj);
u8 handle_21_GO_X(obj_t* obj);
u8 handle_22_GO_Y(obj_t* obj);
u8 handle_12_GO_GOTO(obj_t* obj);
u8 handle_8_GO_STATE(obj_t* obj);
u8 handle_5_GO_SUBSTATE(obj_t* obj);
u8 handle_6_GO_SKIP(obj_t* obj);
u8 handle_9_GO_PREPARELOOP(obj_t* obj);
u8 handle_13_GO_GOSUB(obj_t* obj);
u8 handle_14_GO_RETURN(obj_t* obj);
u8 handle_10_GO_DOLOOP(obj_t* obj);
u8 handle_33_INVALID_CMD(obj_t* obj);
u8 handle_15_GO_BRANCHTRUE(obj_t* obj);
u8 handle_16_GO_BRANCHFALSE(obj_t* obj);
u8 handle_31_GO_SKIPTRUE(obj_t* obj);
u8 handle_32_GO_SKIPFALSE(obj_t* obj);
u8 handle_18_GO_SETTEST(obj_t* obj);
u8 handle_17_GO_TEST(obj_t* obj);
u8 readOneCommand(obj_t* obj);
u8 skipOneCommand(obj_t* obj);
void GET_OBJ_CMD(obj_t* obj);
void pushCmdContext(obj_t* obj, u8 count);
void skipToLabel(obj_t* obj, u8 label, u8 skip_label_cmd);
void pushToLabel(obj_t* obj, u8 label, u8 skip_label_cmd);
void ObjectUTurnDefault(obj_t* obj);
void DO_WIZARD(obj_t* obj);
s32 get_next_bonus_level(u8 lev);
void TEST_WIZARD(obj_t* obj);
void DO_TARZAN(obj_t* tz_obj);
void DoTarzanPoingCollision(obj_t* obj, s16 sprite);
void allocate_badguy(obj_t* tentacle_obj, s16 which_enemy, s16 xspeed, s16 yspeed);
void DO_PTI_ESQUIVE(obj_t* obj);
void DoPrisePoingCollision(obj_t* obj, s16 sprite);
void DO_PETIT_COUTEAU_COMMAND(obj_t* obj);
void DoPetitCouteauPoingCollision(obj_t* obj, s16 sprite);
void DO_TIRE_BOUCHON_COMMAND(obj_t* obj);
void DoOneUpPoingCollision(obj_t* obj, s16 sprite);
void DoOneUpRaymanCollision(obj_t* obj);
void DoMorningStarPoingCollision(obj_t* obj, s16 sprite);
void DoGrapBonusRaymanCollision(obj_t* obj);
void DoPoingPowerupRaymanCollision(obj_t* obj);
void DoPowerupRaymanCollision(obj_t* obj);
void DoSuperHelicoRaymanCollision(obj_t* obj);
void DoGraineRaymanCollision(obj_t* obj);
void DoWizRaymanCollision(obj_t* obj);
void DoJaugeUpRaymanCollision(obj_t* obj);
void DoGeneratingDoorRaymanCollision(obj_t* obj);
void DO_REDUCTEUR(obj_t* obj);
void DoReducteurRaymanCollision(obj_t* obj);
void DoSignPostRaymanCollision(obj_t* obj);
void TEST_SIGNPOST(void);
void DoPancarteRaymanCollision(obj_t* obj);
void DO_MUSICIEN(obj_t* obj);
void DoMusicienRaymanInZDD(obj_t* obj);
void DO_TEN_COMMAND(obj_t* obj);
void DoGeneBadGuyPoingCollision(obj_t* obj, s16 sprite);
void DoGeneBadGuyRaymanZDD(obj_t* obj);
void DoChasseurPoingCollision(obj_t* obj, s16 sprite);
void DoChasseurRaymanZDD(obj_t* obj);
void DO_CHASSEUR_COMMAND(obj_t* obj);
void DoBadGuy23PoingCollision(obj_t* obj, s16 sprite);
void DoBadGuy23RaymanZDD(obj_t* obj);
void DoBadGuy1PoingCollision(obj_t* obj, s16 sprite);
void DoBadGuy1RaymanZDD(obj_t* obj);
void DO_CCL_COMMAND(obj_t* obj);
void DoCaisseClairePoingCollision(obj_t* obj, s16 sprite);
void DoCaisseClaireRaymanZDD(obj_t* obj);
void DoStalagRaymanZDD(obj_t* obj);
void DO_ENSEIGNE_COMMAND(obj_t* obj);
void DO_JOE_COMMAND(obj_t* obj);
void DoJoeRaymanZDD(obj_t* obj);
void DO_BOUEE_JOE_COMMAND(obj_t* obj);
void DO_PHOTOGRAPHE_CMD(obj_t* obj);
void DoAudioStartRaymanCollision(obj_t* obj);
void DO_SLOPEY_PLAT_CMD(obj_t* obj);
void DO_PIRATE_POELLE(obj_t* pirp_obj);
void DO_PIRATE_POELLE_POING_COLLISION(obj_t* obj, s16 sprite);
void PIRATE_POELLE_REACT(obj_t* obj);
void DO_SPECIAL_PLATFORM(obj_t* obj);
void DoPlatformPoingCollision(obj_t* obj, s16 sprite);

// pmama.c
void pmamaFollowsShip(obj_t* obj);
void init_couteaux(void);
void reset_couteaux(void);
u8 check_couteaux(void);
s8 find_couteau(obj_t* obj);
s32 x_pos(u8 param_1, u8 nb_couteau);
s32 y_pos(s16 param_1, s16 param_2);
s32 y_floor(s16 x, s16 y);
void init_move_couteau(obj_t* obj);
void init_lance_couteau(u8 index);
u8 couteau_frame(s16 spd_x, s16 spd_y);
void update_couteau(obj_t* obj);
void get_cou_zdc(obj_t* obj, s16 *x, s16 *y, s16 *w, s16 *h);
void pma_attaque_suivante(void);
s16 convertspeed(s16 x);
void lance_couteau_parabolique(obj_t* obj);
void lance_couteau_droit(obj_t* obj);
void retour_couteau(obj_t* obj);
void lance_couteau_lineaire(obj_t* in_obj);
void DO_COU_COMMAND(obj_t* obj);
void calc_pma_dir(obj_t* obj);
void DO_PMA_COMMAND(obj_t* obj);
void init_mama_pirate(obj_t* obj);
void PMA_SORT_DU_CANON(obj_t* obj);
void DO_PMA_POING_COLLISION(obj_t* obj, s16 sprite);
s32 pma_get_eject_sens(obj_t* obj);
void DO_COU_ATTER(obj_t* obj);
void DO_PMA_ATTER(obj_t* obj);

// poing.c
void fist_U_turn(u8 a1);
void CALC_FIST_POS(void);
void RAY_THROW_FIST(void);
void RAY_PREPARE_FIST(void);
void RAY_GROW_FIST(void);
void fin_poing_follow(u8 a1);
void POING_FOLLOW(obj_t* obj);
void alter_fist_speed(obj_t* obj);
void switch_off_fist(void);
void DO_POING(obj_t* obj);
void allocatePoingBoum(void);

// poisson.c
void DO_POISSON_VERT_CMD(obj_t* obj);
void DO_POISSON_BLEU_CMD(obj_t* obj);
void DoPoissonBleuPoingCollision(obj_t* obj, s16 sprite);
bool can_free_fish(obj_t* fish);
void DESACTIVE_FISH_COLLIS(obj_t* fish);
void DO_PYRANHA(obj_t* obj);
void DoFishPoingCollision(obj_t* obj, s16 sprite);
void DoPoissonBleuRaymanZDD(obj_t* obj);

// worldmap.c
void TEST_DISPLAY_PTS_WAY(s16 world, s16 connected_world, s16 xpos, s16 ypos);
void DISPLAY_PTS_WAY(void);
void DISPLAY_PLAT_WAY(void);
void DO_MEDAILLONS(void);
void INIT_LEVEL_STAGE_NAME(void);
void INIT_WORLD_STAGE_NAME(void);
void INIT_STAGE_NAME(void);
void CHANGE_STAGE_NAMES(void);
void DO_STAGE_NAMES(void);
void INIT_WORLD_INFO(void);
void INIT_LITTLE_RAY(void);
void RESTORE_RAY(void);
void INIT_CHEMIN(void);
void RESPOND_TO_UP(void);
void RESPOND_TO_DOWN(void);
void RESPOND_TO_RIGHT(void);
void RESPOND_TO_LEFT(void);
void DO_RAYMAN_IN_WLD_MAP(void);
void DO_CHEMIN(void);
void INIT_PASTILLES_SAUVE(void);
void PASTILLES_SAUVE_SAVED(s16 world);
void FIN_WORLD_CHOICE(void);
void DETER_WORLD_AND_LEVEL(void);
void INIT_NEW_GAME(void);
void DO_NOT_SAVE_CHOICE(void);
void INIT_SAVE_CHOICE(void);
void INIT_SAVE_CONTINUE(void);
void DO_COMMANDE_SAVE(void);
void SELECTION_SAVE_OPTION(void);
void INIT_AFFICHE_ECRAN_SAVE(void);
void SAISIE_NOM(void);
void REALISATION_ACTION(void);
void DISPLAY_SYMBOLE(s16 a1, s16 a2, s16 a3, u8 a4);
void INIT_CONTINUE(void);
void CHEAT_MODE_CONTINUE(void);
void MAIN_CONTINUE_PRG(void);
void FIN_CONTINUE_PRG(void);
void INIT_NO_MORE_CONTINUE(void);
void MAIN_NO_MORE_CONTINUE_PRG(void);
void INIT_VIGNET(void);
void INIT_CREDITS(void);
void DO_CREDITS(void);
void INIT_ANIM_VICTOIRE(void);
void DO_RAYMAN_WINS(void);
void INIT_LOADER_ANIM(void);
void DO_LOADER_ANIM(void);
void SPECIAL_INIT(void);
void INIT_LEVEL_ANIM(void);
void DO_LEVEL_ANIM(void);
void FIN_LEVEL_ANIM(void);

// rand.c
s16 myRand(s16 max);
void MakeMyRand(s32 set_seed);

// ray.c
void allocateRayLandingSmoke(void);
void recale_ray_on_liane(void);
void calc_bhand_typ(void);
void IS_RAY_ON_LIANE(void);
void rayMayLandOnAnObject(u8* a1, s16 obj_id);
void set_air_speed(u8 main_etat, u8 sub_etat, s16 param_3, u8 param_4);
void Reset_air_speed(u8 is_rolling_speed);
void determineRayAirInertia(void);
void ray_jump(void);
void ray_inertia_speed(s16 a1, s16 a2, s16 prev_speed_x, s16 a4);
void RAY_SWIP(void);
void RAY_STOP(void);
void RAY_HELICO(void);
void Make_Ray_Hang(s16 a1, s16 a2);
bool AIR(s32 a1);
bool MUR(s32 a1);
void CAN_RAY_HANG_BLOC(void);
void RAY_TOMBE(void);
void RAY_RESPOND_TO_DOWN(void);
void RAY_RESPOND_TO_UP(void);
void RAY_RESPOND_TO_DIR(s16 flip_x);
void RAY_RESPOND_TO_NOTHING(void);
void RAY_RESPOND_TO_BUTTON3(void);
void RAY_RESPOND_TO_FIRE0(void);
void RAY_RESPOND_TO_FIRE1(void);
s16 RAY_BALANCE_ANIM(s16 grp_angle);
void SET_RAY_BALANCE(void);
void RAY_GOING_BALANCE(obj_t* obj);
void RAY_BALANCE(void);
void RAY_FIN_BALANCE(void);
void RayTestBlocSH(void);
void remoteControlRay(void);
void STOPPE_RAY_CONTRE_PAROIS(u8 block);
void RAY_IN_THE_AIR(void);
void terminateFistWhenRayDies(void);
void snifRayIsDead(obj_t* obj);
void rayfallsinwater(void);
u8 RAY_DEAD(void);
void RAY_HURT(void);
void RepousseRay(void);
u8 RayEstIlBloque(void);
void stackRay(void);
void RAY_SURF(void);
void DO_SURF_CHANGE_HAIRS(void);
void DO_PIEDS_RAYMAN(obj_t* obj);
void DO_MORT_DE_RAY(void);
void TEST_FIN_FOLLOW(void);
void RAY_FOLLOW(void);
void RAY_RESPOND_TO_ALL_DIRS(void);
void DO_RAY_ON_MS(void);
void DO_RAYMAN(void);
void INIT_PC(void); // NOTE: maybe these need to be moved to a separate source file?
void FIN_PC(void);
void updateLogo(s32 fade_duration, s32 a2, s32 a3);
void LOAD_SCREEN(void);
void sub_71A84(void);
void sub_71A98(void);
void DO_UBI_LOGO(void);

// save.c
void initGameSave(void);
void doneGameSave(void);
void saveGameState(obj_t* save_obj, save_state_t* save_state);
void restoreGameState(save_state_t* save_state);
s32 get_offset_in_safe_zone(s16 obj_id);
void reset_save_zone_level(void);
void take_bonus(s16 obj_id);
u8 bonus_taken(s16 obj_id);
void storeWorldInfoAcces(void);
void retrieveWorldInfoAccess(void);
void file_size(void);
void SaveGameOnDisk(u8 which_save);
bool LoadGameOnDisk(u8 which_save);
bool LoadInfoGame(u8 which_save);
bool SaveOptionsOnDisk(void);
bool LoadOptionsOnDisk(void);

// saxo.c
void saxoCanAttak(void);
void INIT_SAXO(obj_t* obj);
void allocateNote2(obj_t* note_obj, s16 a2);
void DO_EXPLOSE_NOTE2(obj_t* obj);
void DO_NOTE_CMD(obj_t* obj);
void Cree_Eclat_Note(obj_t* bnote, obj_t* note1, s16 index);
void DO_EXPLOSE_NOTE1(obj_t* obj);
void BonneNote(obj_t* orig_obj);
void DO_NOTE_TOUCHEE(obj_t* obj, s16 sprite);
void DO_NOTE_REBOND(obj_t* obj);
void allocateNote(obj_t* obj);
u8 PrepareAtak(void);
void SAXO_TIRE(obj_t* obj);
void DO_SAXO_COUP(obj_t* obj);
void DO_SAXO2_COUP(obj_t* obj);
void SetSaxoEventPos(obj_t* obj);
void SetSaxoCollNoteBox(obj_t* obj);
void DO_SAXO_COMMAND(obj_t* obj);
void DO_SAXO_ATTER(obj_t* obj);
void DO_SAXO2_COMMAND(obj_t* obj);
void DO_SAXO2_ATTER(obj_t* obj);
void DO_SAXO_MARCHE(obj_t* obj);
void DO_SAXO3_COMMAND(obj_t* obj);
void DO_SAXO3_DEBUT(obj_t* obj);
s32 saxo2_get_eject_sens(void);

// screen.c
void Init_Bande(u8 fnd, s16 width, s16 height, u8* source_buf, u8* dest_buf);
void Display_Back_Screen(s16 plan_width, s16 plan_height, s16 w1, s16 h1, s16 w2, s16 h2);
void Display_Sprite_On_Front(s16 plan_width, s16 plan_height, s16 w1, s16 h1, s16 w2, s16 h2);
void Calcul_Deplacement_Bande(s16 x, s16 plan_width, s16 plan_height);
void Init_Effet_Chaleur(s16 width, s16 height, u8* source_buf, u8* dest_buf);
void Do_Effet_Chaleur(s16 a1, s16 a2);

// skops.c
void swap(s32 a1, s32 a2);
void set_rubis_list(void);
void allocate_rayon(s16 a1, s16 a2);
void allocate_8_petits_rayons(s16 a1, s16 a2);
void do_sko_rayon(void);
void do_sko_rayon2(void);
void start_sko_rayon(s16 a1, s16 a2);
void start_sko_rayon2(s16 a1, s16 a2);
void lance_pince(s32 a1);
s32 sko_get_eject_sens(void);
void DO_SOL_ENFONCE(void);
void DO_SKO_PHASE_0(obj_t* obj);
void DO_SKO_PHASE_1(obj_t* obj);
void DO_SKO_PHASE_2(obj_t* obj);
void DO_SKO_PHASE_3(obj_t* obj);
void DO_SKO_PINCE(obj_t* obj);
void DO_SCORPION_COLLISION(obj_t* obj);
void DO_SCORPION_MORT(obj_t* obj);
void DO_SKO(obj_t* obj);
void SKO_ray_in_zone(obj_t* obj);
void DO_SKO_HIT(obj_t* obj, s16 sprite);
s16 Get_PosLave_Y(void);

// special.c
void new_level_init(void);
void fix_numlevel(obj_t* obj);
void allocate_splash(obj_t* obj);
void DO_BALLE(obj_t* obj);
void DO_TIR(obj_t* obj);
void DO_INTERACT_PLAT(obj_t* obj);
obj_t* oldest_planted(void);
void DO_GROWING_PLATFORM(void);
obj_t* allocateExplosion(obj_t* obj);
void BombExplosion(obj_t* obj);
void MARACAS_GO(obj_t* obj);
s16 ANGLE_RAYMAN(obj_t* obj);
obj_t* allocateNOVA(void);
void DO_NOVA(obj_t* obj);
void DO_NOVA2(obj_t* obj);
s16 NOVA_STATUS_BAR(void);
void DO_REDEYE_FIRE(s16 a1, s16 a2, s16 a3);
void calc_esquive_poing(obj_t* mit_obj, s16* out_diff_x, s16* out_diff_y, s16* out_unk);
s16 allocate_gerbe(void);
void start_pix_gerbe(s16 a1, s16 a2);
void do_pix_gerbes(void);
void START_2_PARTS_CYMBAL_ACTION(obj_t* obj);
void ChangeLevel(void);
void init_moustique(void);
void DO_CORDE_CASSE(obj_t* obj);
void DO_FUMEE_CORDE(s16 x, s16 y);
s32 GetY(s16 x);
void allocateSupHelico(obj_t* mus_obj);
void allocatePaillette(obj_t* obj);
void test_fin_cling(void);

// stoneman.c
void DO_STONEMAN_COMMAND(obj_t* obj);
void DO_STONEDOG_COMMAND(obj_t* obj);
void DoStoneDogPoingCollision(obj_t* obj, s16 sprite);
void DO_STONEBOMB_COMMAND(obj_t* obj);
u8 IS_STONEWOMAN_WAIT(obj_t* obj);
void DO_STONEWOMAN_COMMAND(obj_t* obj);
void DO_NOMOVE_STONEWOMAN_COMMAND(obj_t* obj);
void DO_ONE_STONECHIP_COMMAND(obj_t* obj);
void setStoneChipPos(obj_t* obj1, obj_t* obj2, u8* param_3);
void allocateStoneChips(obj_t* obj);
void DO_STONE_EXPLOSION(obj_t* obj, s16 sprite);
void allocateStonemanStone(obj_t* stmn_obj, s16 param_2, u8 param_3);
void DO_STONEMAN1_TIR(obj_t* obj);
void DO_STONEMAN2_TIR(obj_t* obj);
void allocateStonewomanStone(obj_t* stwmn_obj, s16 param_2);
void DO_STONEWOMAN_TIR(obj_t* obj);
void allocateEclatPS(obj_t* obj, s16 param_2);
void DO_PI_EXPLOSION(obj_t* obj);
void DoPiMusPoingCollision(obj_t* obj, s16 sprite);
void DoPiPoingCollision(obj_t* obj, s16 sprite);
void DO_PNG_COLL_STONEMAN(obj_t* obj, s16 sprite);
void DO_PNG_COLL_STONEWOMAN(obj_t* obj, s16 sprite);
void DoStoneMan1et2RaymanZDD(obj_t* obj);
void DoStoneDogRaymanZDD(obj_t* obj);

// trumpet.c
void DO_TRP_COMMAND(obj_t* obj);
void trompetteWind(obj_t* obj, u8 a2);
void DO_TRP_ATTAK(obj_t* obj);
void trompetteAtter(obj_t* obj);
void DoTrumpetPoingCollision(obj_t* obj, s16 sprite);
void DoTrompetteRaymanZDD(obj_t* obj);

// ufo.c
void test_block_chdir(obj_t* obj, s16 a1, s16 a2);
void DO_MOVING_WITH_INDICATOR_COMMAND(obj_t* obj);
void DO_IDC_COMMAND(obj_t* obj);
void DO_LEV_POING_COLLISION(obj_t* obj, s16 sprite);
void START_UFO(obj_t* obj);

// The function prototypes below are from misc source files (may need some cleanup).

// engine.c
void advance_frame(void);
void game_init_sound(game_sound_buffer_t* sound, s32 samples_per_second);
void game_init(game_state_t* game);
void destroy_image(image_t* image);

// platform routines
s64 get_clock(void);
float get_seconds_elapsed(s64 start, s64 end);
// sound.c
void lock_audio(void);
void unlock_audio(void);
void game_get_sound_samples(game_sound_buffer_t* output_buffer);
s16 play_digi_snd(snd_t* snd);
void play_cd_track(s32 track_number, bool looping);
void stop_cd_music(void);
ogg_t open_cd_vorbis(s32 track_number, bool looping);
void stop_ogg(ogg_t* ogg);
void play_ogg(game_sound_buffer_t* sound_buffer, ogg_t* ogg);
void manage_snd_event(void);
void SetVolumeSound(s16 volume);
void stop_all_snd(void);
void stop_ray_snd(void);
u8 get_pan_snd(obj_t* obj);
s32 get_vol_snd(obj_t* obj);
void raj_env_sound(s16 volume);
void raj_env_audio(s16 enabled);
bool raj_env_stereo(s16 stereo);
bool InitSnd(void);
s16 last_snd(s32 obj_id);
s32 get_pile_obj(s16 obj_id);
s32 get_voice_obj(s32 obj_id);
s32 get_voice_snd(s32 snd);
s32 get_voice_obj_snd(s16 obj_id, s16 snd);
void erase_pile_snd(s16 obj_id);
void nettoie_pile_snd(void);
void erase_voice_table(s32 obj_id);
u8 snd_in_pile_snd(s16 snd);
s32 vol_r(s16 a1, s16 a2);
s32 vol_l(s16 a1, s16 a2);
void PlaySnd(s16 snd, s16 obj_id);
void PlaySnd_old(s16 sound_id);
void setvol(s16 obj_id);
void setpan(s16 obj_id);
void manage_snd(void);
void mute_snd_bouclant(void);
void mute_snd(void);
void start_freeze_snd(void);
void stop_freeze_snd(void);
void PlayTchatchVignette(s32 snd);
void TestCdLoop(void);
void InitMusic(void);
void DoneMusic(void);

// render.c
void render_weird_gradient(surface_t* surface, int x_offset, int y_offset);
void render_clear(surface_t* surface, rgb_t color);
void surface_blit_palettized_image(image_t* source, rgb_palette_t* palette, rect_t* source_rect, surface_t* target, rect_t* target_rect);

// save.c
void set_medaillion_saved_data(void);
void load_sav(u8 which_save);
void reset_items_and_bosses(void);

// misc_source.c
void SpriteFixeOffset(mem_t* mem);
void SpriteWorldOffset(mem_t* mem);
void SpriteFixeBlocksFree(mem_t* mem);
void SpriteWorldBlocksFree(mem_t* mem);
u8 decode_xor(u8* data, u32 size, u8 encoding_byte, u8 checksum_byte);
void SetPalette(rgb_palette_t* palette, u8 first_color, s32 num_colors);
void set_special_key_descriptions(const char** descriptions);
image_t load_vignet_pcx(u32 resource_id);
void detect_and_remove_invalid_link_cycles();

#ifdef __cplusplus
}
#endif

#endif //PROTO_H
