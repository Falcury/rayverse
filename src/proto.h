
// (win32/linux)_main.cpp
#ifdef _WIN32
void win32_advance_frame(app_state_t* app_state);
void win32_prepare_frame(app_state_t* app_state);
void win32_end_frame(app_state_t* app_state);
#else
void linux_advance_frame(app_state_t* app_state);
void linux_prepare_frame(app_state_t* app_state);
void linux_end_frame(app_state_t* app_state);
#endif
void message_box(const char* message);

// lowlevel.c
void display_emptypicture(void);
void display_anypicture(void);
void select_display_buffer(u8* buffer);
void InitFirstModeVideo(void);
void InitModeNormal(void);
void InitModeX(void);
void block_clear(u8* source, u8* dest);
void block_copy(u8* source, u8* dest);
void textmode(void);
void draw_sprite_deform(void);
void DisplayBufferModeNormal(u8* source, u8* dest);
void DrawWldPointPlan2Normal(u8* buffer, i32 x, i32 y);
void DrawBlackBoxNormal(u8* buffer, i32 x, i32 y, i32 height, i32 width);
void DrawFondBoxNormal(u8* buffer, i32 x, i32 y, i32 height, i32 width, u8 fond_type);
void DrawBorderBoxNormal(u8* buffer, i32 x, i32 y, i32 height, i32 width, u16 colors);
void DisplayAnyPictureNormal(u8* source_buffer, u8* dest_buffer, i32 source_x, i32 source_y, i32 dest_x, i32 dest_y, i32 stride, i32 width, i32 height);
void ClearDrawAndDisplayBufferNormal(u8* draw_buf, u8* display_buf);
void N_CLRSCR(u8* buffer);
void Swap_To_Screen(u8* draw_buf, u8* display_buf, i32 width, i32 height);
void clear_borders_Normal(u8* buffer, i32 height, i32 width);
void Copy_Plan0Diff_To_Buf(u8* source, u8* dest, i32 width, i32 height, i32 draw_width);
void Display_Bloc(void* a1, void* a2);
void Display_Bloc_Plein(void* a1, void* a2);
void Clip(void);
void Display_Bloc_Clippe(void* a1, void* a2, i16 a3, i16 a4);
void Display_Bloc_Plein_Clippe(void* a1, void* a2, i16 a3, i16 a4);
void fplot_Normal(u8* buffer, i32 x, i32 y, u8 color);
void flocon_clipping(i32 h1, i32 h2, i32 w1, i32 w2);
void draw_flocon5_Normal(void);
void draw_flocon1_Normal(void);
void draw_flocon2_Normal(void);
void draw_flocon3_Normal(void);
void draw_pluie4_Normal(void);
void draw_flocon4_Normal(void);
void draw_pluie5_Normal(void);
void draw_flocon7_Normal(void);
void draw_pluie6_Normal(void);
void draw_flocon6_Normal(void);
void draw_pluie7_Normal(void);
void get_joy_input2_dos1(u8* source_buf, u8* dest_buf, i32 width, i32 height); // ?
void get_joy_input2_dos2(u8* source_buf, u8* dest_buf, i32 width, i32 height); // ?
void get_joy_input2_windows1(u8* source_buf, u8* dest_buf, i32 width, i32 height);
void get_joy_input2_windows2(u8* source_buf, u8* dest_buf, i32 width, i32 height);
void dos_game_io_port_something(void);
void dos_game_io_port_something2(void);
void get_joy_input1_dos1(void);
void get_joy_input1_dos2(void);
void DetectCpu(void);
void default_sprite_clipping(void);
void get_sprite_clipping(i32* xmin, i32* xmax, i32* ymin, i32* ymax);
i32 get_sprite_clipping_xmin(void);
i32 get_sprite_clipping_xmax(void);
i32 get_sprite_clipping_ymin(void);
i32 get_sprite_clipping_ymax(void);
void sprite_clipping(i32 xmin, i32 xmax, i32 ymin, i32 ymax);
bool clip_sprite_on_screen(i32* x, i32* y, vec2b_t* size, u8** image_data);
bool clip_sprite_on_screen_flipped(i32* x, i32* y, vec2b_t* size, u8** image_data);
void DrawSpriteFlipNoClipX(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteX(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNoClipX(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteFlipX(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteColorX(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteColorFlipX(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNormalNoClip(i32 x, i32 color, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNormal(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteNormal256(i32 x /*eax*/, i32 sprite_field_A /*edx*/, i32 y /*ebx*/, vec2b_t size /*ecx*/, u8* draw_buf /*edi*/, u8* image_data /*esi*/);
void DrawSpriteFlipNormalNoClip(i32 x, i32 color, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteFlipNormal(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteFlipNormal256(i32 x /*eax*/, i32 sprite_field_A /*edx*/, i32 y /*ebx*/, vec2b_t size /*ecx*/, u8* draw_buf /*edi*/, u8* image_data /*esi*/);
void DrawSpriteColorNormal(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
void DrawSpriteColorFlipNormal(i32 x, i32 sprite_field_A, i32 y, vec2b_t size, u8* draw_buf, u8* image_data);
bool DrawSpriteDiffNormal_clip(i32* x, i32* y, vec2b_t* size, u8** image_data);
void DrawSpriteDiffNormal(i32 x, i32 y, vec2b_t size, u8* mask, u8* draw_buf, u8* image_data);
void synchro(void);
void endsynchro(void);
void set_speaker_on(void);
void set_speaker_off(void);
void clock_ticks(void);
void wait_until(i32 target);
void speaker_enable(void);

// pcmain.c
void InitData(void);
void DO_GROS_MOTEUR_NORMAL(u8 need_update_display_map);
void DO_MAIN_LOOP_PC_NORMAL(u8* a1);
void DO_GROS_MOTEUR_X(u8* a1);
void DO_MAIN_LOOP_PC_X(void);
void init_arg(i32 argc, char** argv);
void PrintDosInfo(void);
void InitMemoryVariable(void);
void AllocVariablesAutorisee(void);
void AfficheEntete(void);
int main_Ray(int argc, char** argv);
void PcMain(void);

// action.c
void setBossReachingSpeeds(obj_t* obj, u8 horloge_ind, u8 unk_x, u8 unk_y);
i16 testActionEnd(obj_t* obj);
i16 firstFloorBelow(obj_t* obj);
void adjustBossScrollLocker(void);
void setBossScrollLimits(obj_t* obj);

// affiche.c
void display2(obj_t* obj);
void display_sprite(obj_t* obj, u8 sprite_index, i16 x, i16 y, u8 flipped);
void display_sprite_NoClip(obj_t* obj, u8 sprite_index, i16 x, i16 y, u8 flipped);
void DISPLAY_POING(void);
void DISPLAY_CLING(void);
void display_bar_boss(obj_t* boss_obj);
void DisplayCrackers(void);
void DisplayProgrammerMessage(void);
void DISPLAY_FIXE(i32 time);
void DISPLAY_POINT(i16 x, i16 y);
void DISPLAY_PTS_TO(i16 origin_x, i16 origin_y, i16 dest_x, i16 dest_y, i16 a5);
void DISPLAY_PTS_TO_PLAN2(i16 origin_x, i16 origin_y, i16 dest_x, i16 dest_y, i16 percent);
void DISPLAY_CYMBALE(obj_t* obj, u8* draw_buf, u8 a3);
void DISPLAY_ALL_OBJECTS(void);
void display_flocons_behind(void);
void display_flocons_before(void);
void display_pix_gerbes(void);
void DISPLAY_BLACKBOX(i16 x, i16 y, i16 width, i16 height, i16 font_size, u8 is_fond);
void display_text(const char* text, i16 x, i16 y, u8 font_size, i8 color);
void display_deform_text(const char* text, i16 x, i16 y, u8 font_size, i8 color, i16 rotation, i16 enx, i16 eny);
void display_text_sin(const char* text, i16 x, i16 y, u8 font_size, i8 color, u8 a6);
void display_box_text(display_item_t* box);
void CLRSCR(void);
void display_etoile(i16 in_x, i16 in_y);
void display_grp_stars(void);
void DISPLAY_TEXT_FEE(void);
void DISPLAY_SAVE_SPRITES(i16 x, i16 save_index);
void DISPLAY_SAVE_POING(void);
void DISPLAY_OPTIONS_POING(void);
void DISPLAY_YESNO_POING(void);
void display_time(i32 a1);
void DISPLAY_CONTINUE_SPR(void);
void AFFICHE_SPRITE_DEFORME(void* a1, i32 a2, i16 a3, i16 a4, i16 a5, i16 a6, i16 a7, i16 a8, i16 a9, i16 a10);
void DISPLAY_DEFORMATION(obj_t* obj, i16 a2, i16 a3, i16 a4);
void DISPLAY_DEFORM_SPRITE(void* a1, i32 a2, i16 a3, i16 a4, i16 a5, i16 a6, i16 a7);
void CALCUL_DEFORMATION(i16* a1, i16* a2, i16 a3, i16 a4, i16 a5);

// araignee.c
void get_spi_zdc(obj_t* obj, i16* x, i16* y, i16* w, i16* h);
void DO_SPIDER_PLAFOND(obj_t* obj);
void DO_SPIDER_PLAFOND_POING_COLLISION(obj_t* obj, i16 sprite);
void SPIDER_PLAFOND_REACT(obj_t* obj);
void DO_DARD_PLAFOND_ALWAYS(obj_t* obj);
void DO_SPIDER_COMMAND(obj_t* obj);
void DO_SPIDER_TIR(obj_t* obj);
void allocateDard(obj_t* obj);
void DoSpiderPoingCollision(obj_t* obj, i16 sprite);
void DoSpiderRaymanZDD(obj_t* obj);

// audiocd.c
void SetCompteurTrameAudio(void);
void DoCdCredits(void);
void start_cd_credits(void);
void start_cd_ubi_soft(void);
void start_cd_gagne(void);
void start_cd_suspence(void);
void start_cd_gros_rayman(void);
void start_cd_perdu(void);
void DoCdRap(void);
void start_cd_bbdead(void);
void start_cd_gameover(void);
void stop_cd(void);
bool cd_playing(void);

// basic.c
bool EOA(obj_t* obj);
void save_objects_flags(void);
void restore_objects_flags(void);
void snapToSprite(obj_t* obj1, obj_t* obj2, u8 a3, i16 a4, i16 a5);
obj_t* findfirstObject(i16 obj_type);
void findfirstInactiveObject(i16 a1);
i32 sinYspeed(obj_t* obj, i16 a2, i16 a3, i16* a4);
void set_proj_center(i16 x, i16 y);
i32 get_proj_dist(i16 scale, i16 outer_dim);
i32 get_proj_dist2(i16 scale, i16 a2);
i32 get_proj_x(i16 scale, i16 a2);
i32 get_proj_y(i16 scale, i16 a2);
void set_zoom_mode(u8 mode);
i32 inverse_proj_x(i16 scale, i16 a2);
i32 inverse_proj_y(i16 scale, i16 a2);
i32 vblToEOA(obj_t* obj, u8 a2);
void GET_ANIM_POS(obj_t* obj, i16* x, i16* y, i16* w, i16* h);
void add_actobj(i16 a1);
void set_sub_etat(obj_t* obj, u8 sub_etat);
void set_main_etat(obj_t* obj, u8 etat);
void set_main_and_sub_etat(obj_t* obj, u8 etat, u8 sub_etat);
i16 get_center_x(obj_t* obj);
i16 get_center_y(obj_t* obj);
u8 on_block_chdir(obj_t* obj, i16 center_x, i16 center_y);
void CALC_FOLLOW_SPRITE_SPEED(obj_t* obj, anim_t* anim_1, anim_t* anim_2, i16 anim_frame_2);
u8 GET_SPRITE_POS(obj_t* obj, i16 index, i16* x, i16* y, i16* w, i16* h);
void GET_RAY_ZDC(obj_t* obj, i16* x, i16* y, i16* w, i16* h);
void GET_BB1_ZDCs(obj_t* obj, i16* a2, i16* a3, i16* a4, i16* a5, i16* a6, i16* a7, i16* a8, i16* a9);
void calc_obj_dir(obj_t* obj);
u8 OBJ_IN_ZONE(obj_t* obj);
void calc_obj_pos(obj_t* obj);
void makeUturn(obj_t* obj);
u8 BTYP(i32 tile_x, i32 tile_y);
void calc_btyp_square(obj_t* obj);
void DO_OBJ_REBOND_EN_X(obj_t* obj);
u8 calc_btyp(obj_t* obj);
void init_obj_in_the_air(obj_t* obj);
void make_my_fruit_go_down(obj_t* obj, i16 x_accel);
void switchOff(obj_t* obj);
void obj_hurt(obj_t* target);
void Projectil_to_RM(obj_t* obj, i16* out_spd_x, i16* out_spd_y, i16 new_spd_x, i16 new_spd_y);
void del_actobj(obj_t* obj);
i32 calc_let_Width(u8 font_size, i32 num_let);
i32 calc_let_Width2(u8 font_size, i32 num_let);
void INIT_TEXT_TO_DISPLAY(void);
i32 deter_num_let(u8 c, const char* next_chars);
void calc_num_let_spr(u8 a1, u8* a2);
i16 calc_largmax_text(const char* text, i16 char_index, i16 space_width, i16 char_spacing, u8 font_size);
void INIT_TXT_BOX(display_item_t* box);
void Deter_Option_Caract(char* text, i16 key, i16 offset);
void SwapAB(i16* a, i16* b);
void Bresenham(void (*func)(i16, i16), i16 origin_x, i16 origin_y, i16 dest_x, i16 dest_y, i16 param_6, i16 percent);
void init_finBossLevel(void);
void Change_Wait_Anim(void);
void add_alwobj(obj_t* obj);
void del_alwobj(i16 obj_index);
void FatalError(char* message);
u8 sprite_of_ref(obj_t* obj, u8 a2);

// bat.c
void DO_BAT_FLASH(i16 a1, i16 a2);
void DO_BAT_LEFT_FLASH(obj_t* obj);
void DO_BAT_RIGHT_FLASH(obj_t* obj);
void DO_BAT_LEFT_RIGHT_FLASH(obj_t* obj);
i16 bat_dir(obj_t* obj);
void DO_BAT_COMMAND(obj_t* obj);
void BAT_ray_in_zone(obj_t* obj);
void DO_BAT_POING_COLLISION(obj_t* obj, i16 sprite);
i32 bat_get_eject_sens(obj_t* obj);

// bbmont.c
void BB2_MARCHE(obj_t* obj);
void DO_TOTEM_TOUCHE(obj_t* obj, i16 sprite);
void DO_TOTEM_COMMAND(obj_t* obj);
void DO_TOTBT_REBOND(obj_t* obj);
void DO_PI_EXPLOSION2(obj_t* obj);
void DO_BBL_REBOND(obj_t* obj);
void allocateDog(obj_t* obj);
void allocateTir(obj_t* obj, i16 a2);
void CreateFirstBBL(void);
void INIT_BBMONT(obj_t* obj);
void DO_BBL_COMMAND(obj_t* obj);
void BBMONT_ECLAIR(obj_t* obj);
void BBMONT_ETINCELLES(obj_t* obj);
void BBMONT_TIRE(obj_t* obj);
void Cree_BBL(obj_t* obj);
void BB_Attaque(obj_t* obj);
void Fin_BB_Attaque(obj_t* obj);
void BB_Atan(obj_t* obj);
void DO_BBMONT_ATTER(obj_t* obj);
void DO_BBMONT_COMMAND(obj_t* obj);
void DO_BBMONT_TOUCHE(obj_t* obj, i16 sprite);
void DO_BBMONT2_COMMAND(obj_t* obj);
void DO_BBMONT2_MARCHE(obj_t* obj);
void DO_BBMONT2_ATTER(obj_t* obj);
void DO_BBMONT3_COMMAND(obj_t* obj);
void DO_BBMONT3_ATTER(obj_t* obj);
void DO_BBMONT4_COMMAND(obj_t* obj);
void DO_ECLAIR_COMMAND(obj_t* obj);
void DO_BB1_PLAT_CMD(obj_t* obj);

// blacktoon.c
void allocateBlacktoonEyes(obj_t* obj);
void DO_BLK_SPEED_COMMAND(obj_t* obj);
void blkUTurn(obj_t* obj);
void DO_BLK_LR_COMMAND(obj_t* obj);
void DO_BLK_NOP_COMMAND(obj_t* obj);
void DO_BLKTOON_COMMAND(obj_t* obj);
void DoBlackToonPoingCollision(obj_t* obj, i16 sprite);
void DoBlackToonRaymanZDD(obj_t* obj);

// blood.c
void DoEffectBloodOut(void);

// bonus.c
i16 get_allowed_time(void);
void calc_left_time(void);
u8 get_bonus_map_complete(i16 world, i16 lvl);
void set_bonus_map_complete(i16 world, i16 lvl);
void DO_WIZ_AFTER_BONUS_MAP(void);
void init_bonus_perfect(void);
i16 do_perfect_bonus(u32 a1);
void DO_PERFECT_BONUS_MAP(void);

// box.c
void CalcTab(void);
void InitPlasma(u8 need_set_palette);
void Plasma(i16 x, i16 y, i16 width, i16 height, u8 a5, u8 a6, u8 a7, u8 a8, u8 a9, u8 a10, u8 a11, u8 a12, u8 a13);
void PlasmaBox(i16 x, i16 y, i16 width, i16 height, u8 a5);
void InitFire(void);
void Fire(i16 x, i16 y, i16 width, i16 height);
void FireBox(i16 x, i16 y, i16 width, i16 height);
void InitMenuPalette(void);
void CaptureVideo(u8* source_buf, u8* dest_buf, u8 grayscale);
void CadreTrans(i16 x, i16 y, i16 w, i16 h);
void DrawBlackBorderBox(i16 x, i16 y, i16 height, i16 width, u8 a5);
void InitGauge(void);
void gauge(i16 a1, i16 a2, i16 a3, i16 a4, i16 a5, i16 a6, i16 a7);
void ClearBorder(i16 lim_H1, i16 lim_H2, i16 lim_W1, i16 lim_W2);

// blocs.c
u8 MURDUR(i16 x, i16 y);
i32 dist_to_bloc_floor(i16 btype, i16 x, i16 y);
u8 bloc_floor(i16 btype, i16 x, i16 y);
u8 calc_typ_trav(obj_t* obj, u8 a2);
u8 calc_typ_travd(obj_t* obj, u8 a2);
void TEST_FIN_BLOC(obj_t* obj);
u8 TEST_IS_ON_RESSORT_BLOC(obj_t* obj);
u8 IS_ON_RESSORT_BLOC(obj_t* obj);
void CALC_MOV_ON_BLOC(obj_t* obj);
void recale_position(obj_t* obj);
i32 blocs1_empty(i32 x, i32 y);
i32 blocs1_right_45(i32 x, i32 y);
i32 blocs1_left_45(i32 x, i32 y);
i32 blocs1_right1_30(i32 x, i32 y);
i32 blocs1_right2_30(i32 x, i32 y);
i32 blocs1_left1_30(i32 x, i32 y);
i32 blocs1_left2_30(i32 x, i32 y);
i32 blocs3_empty(i32 x, i32 y);
i32 blocs1_liane(i32 x, i32 y);
i32 blocs4_empty(i32 x, i32 y);
i32 blocs1_hor(i32 x, i32 y);
i32 blocs2_empty(i32 x, i32 y);
void init_calcbloc_func(void);

// breakout.c
u8 get_casse_brique_ON(void);
void set_casse_brique_ON(u8 on);
u8 get_casse_brique_active(void);
void set_casse_brique_active(void);
void enter_casse_brique(void);
void enter_casse_brique2(void);
void exit_casse_brique(void);
void exit_casse_brique2(void);
i32 get_speed_ball(void);
void speed_ball_null(obj_t* obj);
void speed_ball_init(obj_t* obj);
void speed_up_ball(obj_t* obj);
void invert_speed_ball_x(obj_t* obj);
void invert_speed_ball_y(obj_t* obj);
void set_ball_pos(obj_t* obj, i16 a2, i16 a3);
void angle_direction(i16 a1, i16 a2);
void move_ball(obj_t* obj);
void get_brik_bonus(void);
void do_bonus(void);
void get_brik_info(obj_t* obj, i16 a2, i16* a3, i16* a4, u8* a5);
void frame_briques(obj_t* obj);
void AllocateCasseBriqueBoum(obj_t* obj);
void AllocateBonus(obj_t* obj, i16 a2, u8 a3, u8 a4);
void bonus_fall(obj_t* obj);
void collision_briques(obj_t* obj);
void collision_rayman(obj_t* obj);
void move_briques(obj_t* obj);
void init_briques(obj_t* obj);
void reset_briques(void);
void casse_brique_init(obj_t* obj);
void casse_brique_start(obj_t* obj);
void ray_face_brik(i16 a1);
void casse_brique_play(obj_t* obj);
void casse_brique_end(obj_t* obj);
void casse_brique_done(obj_t* obj);
void DISPLAY_FIXE_CB(obj_t* obj);
void DO_CB_BALL_COMMAND(obj_t* obj);
void DO_CB_BRIK_COMMAND(obj_t* obj);
void DO_RAY_CASSE_BRIQUE(void);

// cage.c
void DO_CAGE2(obj_t* obj);
void DO_CAGE(obj_t* obj);
void DoCagePoingCollision(obj_t* obj, i16 sprite);
void DO_MEDAILLON_TOON(obj_t* obj);
void DO_MEDAILLON_TOON_GELE(void);
void ALLOCATE_MEDAILLON_TOON(void);
void allocate_toons(obj_t* src_obj, u8 count);
void allocateGrille(obj_t* obj);
void DO_ONE_PINK_CMD(obj_t* obj);
void DoLidolPinkRaymanZDD(obj_t* obj);

// clown.c
void DO_CLOWN_TNT_COMMAND(obj_t* obj);
void DO_CLOWN_TNT2_COMMAND(obj_t* obj);
void DO_CLOWN_TNT3_COMMAND(obj_t* obj);
void DO_BIG_CLOWN_ATTAK(obj_t* obj);
void allocatedrop(obj_t* obj);
void DO_WAT_CLOWN_ATTAK(obj_t* obj);
void DO_CLOWN_TNT_ATTACK(obj_t* obj);
void Clown_Music_Atter(obj_t* obj);
void DoWatAndBigClownPoingCollision(obj_t* obj, i16 sprite);
void DoTntClownPoingCollision(obj_t* obj, i16 sprite);
void DoWatAndBigClownRaymanZDD(obj_t* obj);
void DoTntClownRaymanZDD(obj_t* obj);

// collision.c
i32 get_nb_zdc(obj_t* obj);
i32 get_zdc_index(obj_t* obj);
zdc_t* get_zdc(obj_t* obj, i32 a2);
u16 get_ZDCPTR(void);
i32 in_coll_sprite_list(obj_t* obj, i16 a2);
bool box_inter_v_line(i16 a1, i16 a2, i16 a3, i16 a4, i16 a5, i16 a6, i16 a7);
bool box_inter_h_line(i16 a1, i16 a2, i16 a3, i16 a4, i16 a5, i16 a6, i16 a7);
i16 inter_box(i32 x_1, i32 y_1, i32 w_1, i32 h_1, s16 x_2, s16 y_2, i32 w_2, i32 h_2);
void GET_OBJ_ZDC(obj_t* obj, i16 *out_x, i16 *out_y, i16 *out_w, i16 *out_h);
i16 GET_SPRITE_ZDC(obj_t* obj, i16 index, i16 *out_x, i16 *out_y, i16 *out_w, i16 *out_h);
i32 BOX_HIT_SPECIAL_ZDC(i16 x, i16 y, i16 w, i16 h, obj_t* obj);
i32 BOX_IN_COLL_ZONES(i16 type, i16 x, i16 y, i16 w, i16 h, obj_t* obj);
i32 COLL_BOX_SPRITE(i16 x, i16 y, i16 w, i16 h, obj_t* obj);
i16 CHECK_BOX_COLLISION(i16 type, i16 x, i16 y, i16 w, i16 h, obj_t* obj);
i16 possible_sprite(obj_t* obj, i16 index);
i16 setToleranceDist(i16 x, i16 w, i16 y);
void SET_RAY_DIST_SLOPEY_PLAT(obj_t* obj);
void SET_RAY_DIST_MULTISPR_CANTCHANGE(obj_t* obj);
void SET_RAY_DIST_PI(obj_t* obj);
void SET_RAY_DIST_BAG(obj_t* obj);
void SET_RAY_DIST(obj_t* obj);
void do_boum(void);
void DO_POING_COLLISION(void);
void DoPoingCollisionDefault(obj_t* obj, i16 sprite);
void COLL_BOX_ALL_SPRITES(i16 a1, i16 a2, i16 a3, i16 a4, obj_t* obj);
bool COLL_RAY_PIC(void);
void COLL_RAY_BLK_MORTEL(void);
void RAY_KO(void);
void RAY_HIT(bool hurt, obj_t* obj);
void standard_frontZone(obj_t* obj, i16* x, i16* w);
void SET_DETECT_ZONE_FLAG(obj_t* obj);
void goToRay(obj_t* obj);
void unleashMonsterHost(obj_t* obj);
void SHOW_COLLISIONS_ZONES(void);
void DO_COLLISIONS(void);
void DoRaymanCollisionDefault(obj_t* obj);
void DO_OBJ_COLLISIONS(obj_t* obj, i16 offs);
u8 test_allowed(obj_t* obj, i16 center_x, i16 center_y);
void obj_jump(obj_t* obj);
void DO_MOVING_PLATFORM_COMMAND(obj_t* obj);
void DoPTGRAPPINPoingCollision(obj_t* obj, i16 sprite);
void DO_ONE_CMD_WAIT(obj_t* obj); // TODO: maybe make a split here: command.c?
void DO_ONE_CMD_LR_ATTENTE(obj_t* obj);
void DO_ONE_CMD_UPDOWN(obj_t* obj);
void special_pour_liv(obj_t* event);
void DO_ONE_CMD(obj_t* obj);
void DO_ROLL_EYES(obj_t* obj);
void DoKillingEyesPoingCollision(obj_t* obj, i16 sprite);
void YaUnBloc(obj_t* obj);
void DO_BAG1_COMMAND(obj_t* obj);
void DoRaymanBag1Collision(obj_t* obj);
i16 MarCoince(obj_t* obj, i16 dir);
void DO_MOVE_MARACAS_COMMAND(obj_t* obj);
void DO_FLASH_COMMAND(obj_t* obj);
void DO_WLKNOT_COMMAND(obj_t* obj);
void ACTIVE_L_EAU(obj_t* eau_obj);
void DO_EAU_QUI_MONTE(obj_t* obj);
void allocateOtherPosts(obj_t* her_bh_obj);
void doHerseCommand(obj_t* obj);
void doBlackRaymanCommand(obj_t* obj);
void doBlKRayRaymanCollision(obj_t* obj);
void DO_POELLE_COMMAND(obj_t* po_obj);
void DO_CORDE_COMMAND(obj_t* obj);
void DO_PAC_COMMAND(obj_t* obj);
void DO_CFUMEE_COMMAND(obj_t* obj);
void DO_NOVA2_COMMAND(obj_t* obj);
void doShipCommand(obj_t* obj);
void DO_PROP_COMMAND(obj_t* obj);
void move_fruit_in_water(obj_t* obj);
void DO_FALLING_OBJ_CMD(obj_t* obj);
void DoFallingObjPoingCollision(obj_t* obj, i16 sprite);
void DO_BLKTOON_EYES_CMD(obj_t* obj);
void DO_RAY_POS_CMD(obj_t* obj);

// compress.c
// (todo)

// cymbal.c
void DO_CYMBAL_COMMAND(obj_t* obj);
void DO_2_PARTS_CYMBAL(obj_t* cym_obj);
void DO_COLL_RAY_CYMBALE(obj_t* cym_obj);

// dark.c
void PlaceDarkPhase1et2(obj_t* obj);
void dark_attaque_suivante(obj_t* obj);
void init_vitraux(void);
void poing_face_obj(obj_t* obj);
void DARK_phase1(obj_t* obj);
void DARK_phase3(obj_t* obj);
void DO_DARK_COMMAND(obj_t* obj);
void DO_DARK_POING_COLLISION(obj_t* obj, i16 sprite);
void DO_DARK_REACT(obj_t* obj);
void DO_DARK_SORT_COMMAND(obj_t* obj);
void DO_DARK_SORT_COLLISION(obj_t* obj);
void allocate_DARK_SORT(obj_t* obj);
void DoAnnuleDarkSortRaymanCollision(obj_t* obj);
void corde_en_bas(obj_t* obj);
void corde_en_haut(obj_t* obj);
void init_corde(obj_t* obj);
void goto_phase1(obj_t* obj);
void goto_phase2(obj_t* obj);
void goto_phase3(obj_t* obj);
void goto_phase5(obj_t* obj);
void DO_VITRAIL_COMMAND(obj_t* obj);
void allume_vitraux(obj_t* obj);

// display.c
i16 display_inter_anim(u32 a1);
void continue_fonction(void);
void DO_CONTINUE(void);
i16 saisie_nom_prg(u32 a1);
i16 selection_save_option_prg(u32 a1);
void DO_SAVE_CHOICE(void);
void AFFICHE_ECRAN_SAVE(void);
i16 select_level_prg(u32 a1);
i16 SELECT_LEVEL(i16 original_level_choice);
void CLEAR_STAGE_NAMES(void);
void DISPLAY_STAGE_NAMES(void);
i16 WORLD_CHOICE(u32 a1);
void DO_WORLD_MAP(void);
void DISPLAY_TXT_VIGNET(void);
i16 display_vignet_prg(u32 a1);
void DISPLAY_GAME_VIGNET(void);
void DISPLAY_TXT_CREDITS(void);
i16 display_credits_prg(u32 a1);
void display_anim_victoire(void);
void DISPLAY_CREDITS(void);
void DISPLAY_CREDITS_MENU(void);
void DISPLAY_PROTOON_BACK(void);
void DO_ANIM_VICTOIRE(void);
void DO_VICTOIRE(void);
void InitDemoJeu(void);
void FinDemoJeu(void);
i16 loader_anim_prg(u32 a1);
void START_LOADER_ANIM(void);
void END_LOADER_ANIM(void);
void DO_GROS_RAYMAN(void);
void START_LEVEL_ANIM(void);
void PouvoirsParMap(void);
void sub_35F70(void);
void sub_3609C(void);
void sub_36150(void);
void FIRST_INIT(void);
void init_divers_level_PC(u8* a1);
void file_level(i32 level_id, char* filename);
void world_level(i32 world_id, char* filename);
void LoadPlan3InVignet(mem_t* mem, i32 resource_id);
void DISPLAY_AND_FADE_PLAN3(void);
void LOAD_VIGNET_PC(mem_t* mem, i16 world);
void LOAD_SAVE_SCREEN(mem_t* mem);
void LOAD_PERFTIME_SCREEN(mem_t* mem);
void LOAD_PERFECT_SCREEN(mem_t* mem);
void LOAD_CONTINUE_SCREEN(mem_t* mem);
void DISPLAY_FOND_CONTINUE(void);
void SwapPlan2PlanVignInVignet(mem_t* mem, i32 resource_id, i16 vig_index);
void LOAD_VIGNET_GAME(mem_t* mem);
void LOAD_CREDITS_VIGNET(i32 a1, i32 a2, i16 a3);
void DEPART_WORLD(void);
void DEPART_LEVEL(void);
void REMOVE_FICHIER(void);
i32 TestSave(void);
void test_EXIT(void);
void test_Keyb_on_wldmap(void);
void Keyflush(void);
void LOAD_GENERAL_SCREEN(void);
void LOAD_OPTIONS_SCREEN(void);
void HANDLE_KEY(u8* a1);
void DEPART_INIT_LOOP(void);
void DEPART_DEAD_LOOP(void);
void FIN_GAME_LOOP(void);
void FIN_MAP_LOOP(void);
void FIN_DEAD_LOOP(void);
void END_GAME(void);
void INIT_EXTENSIONS(void);
void DISPLAY_LOADING(void);
void START_WORLD_VIGNET(void);
void END_WORLD_VIGNET(void);
void sub_36FAC(void);
void sub_36FBB(void);
void sub_370E8(void);
void sub_37134(void);
bool LOAD_BIG_RAYMAN(mem_t* mem);
bool ValidButPressed(void);
bool StartButPressed(void);
bool PauseButPressed(void);
bool ExitButPressed(void);
bool CancelButPressed(void);
bool SelectButPressed(void);
void ToDoAtExit(void);

// effect.c
void sub_37B90(void);
void sub_37C00(void);
void sub_37C40(void);
void sub_37C98(void);
void sub_37CDC(void);
void sub_37D4C(void);
void sub_37D90(void);
void sub_37E00(void);
void sub_37E44(void);
void sub_37E9C(void);
void sub_37EE0(void);
void sub_37F50(void);
void sub_37F94(void);
void sub_37FEC(void);
void sub_38030(void);
void sub_38054(void);
void sub_38064(void);
void sub_38074(void);
void sub_380A4(void);
u8 sub_38208(i32 a1, i32 a2, u8* a3, u8* a4);
u8 sub_38220(i32 a1, i32 a2, u8* a3, u8* a4);
void sub_38258(void);
void sub_38290(void);
void SaveScreen(u8* a1, u8* a2);
void RestoreScreen(u8* a1, u8* a2);
void DO_AFFICHE_PAUSE(void);
i16 dummy_prg(u32 a1);
void Do_Effect_Pause_Simple(void);
void Do_Effect_Pause_unknown(void);
void Do_Effect_Pause(void);
void sub_38A30(void);
void sub_38B58(void);
void sub_38DA0(void);
void sub_38DCC(void);
void sub_38ED4(void);
void sub_391C0(void);

// fee.c
void INIT_TXT_FEE(void);
void allocate_poing_or_free(void);
void init_fee(void);
void wait_for_dialogue_fee(obj_t* obj, i16 time);
void DO_FEE_ETAPE(obj_t* obj);
void fee_gives_super_evts(void);
void DO_FEE(obj_t* obj);
void DoFeeRaymanZDD(obj_t* obj);

// frame.c
void display_movie_frames(void);
i32 playVideo2(const char* path, const char* filename, i32 a3, u8 a4);
i32 playVideo(const char* path, const char* filename, i32 a3);
i32 playVideo_alt(const char* path, const char* filename, i32 a3);
void SWAP_BUFFERS(void);
void sub_3B580(void);
void sub_3B5E8(void);
void calc_gros_type(void);
void find_in_map(i16 a1, i16 a2);
void init_find_in_map(void);
void end_find_in_map(void);
void build_map(i16 a1, i16 a2);
void build_line_map(void* a1, i16 a2, i16 a3, i16 a4);
void build_column_map(void* a1, i16 a2, i16 a3, i16 a4);
void update_map(i16 a1, i16 a2, i16 a3, i16 a4);
void sub_3BE20(void);
void sub_3BEE0(i16 a1, i16 a2);
void set_vga_frequency(u8 a1);
void GetVideoRegister(void);
void SetVideoRegister(void);
void sub_3C3BC(void);
void clear_palette(rgb_palette_t* palette);
void set_fade_palette(rgb_palette_t* palette);
void start_fade_in(i16 speed);
void start_fade_out(i16 speed);
void do_fade(rgb_palette_t* source_pal, rgb_palette_t* dest_pal);
void fade_out(i16 speed, rgb_palette_t* palette);
void actualize_palette(u8 new_pal_id);
void cyclage_palette(i16 a1, i16 a2, i16 a3);
void DO_SWAP_PALETTE(void);
void DO_FADE(void);
void INIT_FADE_IN(void);
void INIT_FADE_OUT(void);
void DO_FADE_OUT(void);
void EFFACE_VIDEO(void);
void SYNCHRO_LOOP(scene_func_t scene_func);
void DISPLAY_ANYSIZE_PICTURE(void* a1, i16 a2, i16 a3, i16 a4, i16 a5, i16 a6, i16 a7);
void SAVE_PALETTE(rgb_palette_t* palette);
void RESTORE_PALETTE(void);
void SAVE_PLAN3(void);
void RESTORE_PLAN3(void);
void DISPLAY_FOND3(void);
void DISPLAY_FOND_MENU(void);
void InitPaletteSpecialPC(void);
void DoFadePaletteSpecialPC(i16 a1, i16 a2);
void DoPaletteSpecialPC(void);
void InitModeXWithFrequency(u8 freq);
void InitTextMode(void);
void InitModeNormalWithFrequency(u8 freq);
void WaitNSynchro(i32 n_frames);

// guetteur.c
void swapGuetteurCollZones(obj_t* obj, u8 a2);
void guetteurFollowsShip(obj_t* obj);
void DO_ONE_PAR_COMMAND(obj_t* obj);
void hasGuetteurABomb(obj_t* obj);
void allocatePirateGuetteurBomb(obj_t* obj);
void DO_PAR_TIR(obj_t* obj);
void DO_PAR_POING_COLLISION(obj_t* obj, i16 sprite);
void PAR_REACT_TO_RAY_IN_ZONE(obj_t* obj);
void DO_PAR_BOMB_COMMAND(obj_t* obj);

// hifi.c
void sub_3E66C(void);
void sub_3E6B0(void);
void rayman_sound_fatal_error(const char* message);
void sub_3E710(void);
void sub_3E780(void);
void LoadBnkFile(i32 header_index, i32 data_index, bnk_header_t* headers, u8** data);
void LoadBnkFile_debug(i32 sound_set, i32 a2, u8** sound_buffer);
void LoadBnkFixe(void);
void LoadBnkWorld(i16 world);
i16 KeyOn(u8 bank, u8 prog, u8 tone, u8 note, u8 volume, u8 pan);
void KeyOff(u32 voice_id, u8 bank, u8 prog, u8 tone, u8 note);
void KeyVol(i32 voice_id, i32 volume, i32 pan);
void DigiMusicDone(void);
void LoadTchatchPerdu(void);
void PlayTchatch(i32 snd, i32 volume);
void FreeTchatchVignette(void);
void SetPort_(i32 port); // NOTE: extra underscore added because SetPort is also used by the Win32 API (in winspool.h)
void SetIrq(i32 irq);
void SetDma(i32 dma);
void SetParam(i32 param);
void SetDeviceID(i32 device_id);
char* GetDeviceName(void);
i32 GetPort(void);
i32 GetIrq(void);
i32 GetDma(void);
i32 GetParam(void);
i32 GetDeviceID_Ray(void);
void FreeDetectDriver(void);

// hybrid.c
void allocateSTOSKO(void);
void allocateMOSKITOMAMA(obj_t* obj);
void allocateMOSKITOSAXO(obj_t* obj);
void doMOSAMScommand(obj_t* obj);
void DoMOSAMSPoingCollision(obj_t* obj, i16 sprite);
void allocateStoskoClaw(obj_t* obj);
void doSTOSKOcommand(obj_t* obj);
void DoSTOSKOPoingCollision(obj_t* obj, i16 sprite);
void doBBF2command(obj_t* obj);
void DO_HYB_BBF2_POING_COLLISION(obj_t* obj, i16 sprite);
void AllocateTirBBF2(obj_t* obj);
void DO_HYB_BBF2_LAS(obj_t* obj);
void DoHybBBF2LasRaymanCollision(obj_t* obj);
void OBJ_IN_COL_ZDC(obj_t* obj1, obj_t* obj2);
void AllocateDarkPhase2(obj_t* obj);
void DO_DARK2_AFFICHE_TEXT(void);
void DO_DARK_PHASE2_COMMAND(obj_t* obj);
void DO_DARK2_SORT_COMMAND(obj_t* obj);
void allocate_DARK2_SORT(obj_t* obj);
void DoFlammeCommand(obj_t* obj);
void DoFlammeRaymanCollision(obj_t* obj);
void AllocateFlammes(i16 a1);
void AllocateToons(void);
void DO_DARK2_TOONS_COMMAND(obj_t* obj);
void ToonDonnePoing(obj_t* obj);

// input.c
void POINTEUR_BOUTONS_OPTIONS_BIS(void);
u8 TestKeyWeapon(void);
u8 TOUCHE(u8 key);
u8 TestKeyJump(void);
u8 TestKeyAction(void);
i32 leftjoy(void);
i32 rightjoy(void);
i32 downjoy(void);
i32 upjoy(void);
i32 but0pressed(void);
i32 but1pressed(void);
i32 but2pressed(void);
i32 but3pressed(void);
i32 butX0pressed(void);
i32 butX1pressed(void);
void sub_4212C(i16 a1);
void readinput(void);
void readinput_calibrate_joystick(void);
void readinput_center_joystick(void);
void update_pad_limits(i16* xmax, i16* xmin, i16* ymax, i16* ymin, i16* xcentre, i16* ycentre);
void sub_4225C(void);
void read_record(const char* filename);
void load_record(void);
void sub_42408(u8 a1);
void do_record(record_t* rec);
void keyboard_interrupt_handler(void);
void sub_425AB(void);
void RESET_TOUCHE(u8 key);
void RESET_ALL_TOUCHE(void);
void Init_Clavier(void);
void Reset_Clavier(void);
bool JoystickPresent(void);

// jumelle.c
void plot2linejumelle(i32 jumelle_x, i32 jumelle_y, i32 plot_x, i32 plot_y, i32 circle2_offset, u8* effet_buf, u8* draw_buf);
void DisplayJumellesNormal(i32 x, i32 y, i32 rayon, i32 a4, u8* effet_buf, u8* draw_buf);
void InitMatriceJumelle(void);
void DefaultJumelleVariable(void);
void ChangeDeltaSizeJumelle(i32 delta_size);
void CalculVitesseJumelle(void);
void ChangeDeltaPosXJumelleWithoutLimit(i32 delta_pos_x);
void ChangeDeltaPosYJumelleWithoutLimit(i32 delta_pos_y);
i32 ChangeDeltaPosXJumelleWithLimit(i32 delta_pos_x);
i32 ChangeDeltaPosYJumelleWithLimit(i32 delta_pos_y);
void ChangeJumelleVariable(void);
void ChangeDeltaZoomAmpJumelle(i32 a1);
void PrepareJumelleZoom(void);
void RecaleRayPosInJumelle(void);
void DisplayJumellesFondNormal(void);
void DoScrollInWorldMap(i16 h_speed, i16 v_speed);
void CalcObjPosInWorldMap(obj_t* obj);
void MoveRayInWorldMap(void);

// load.c
void load_world(mem_t* mem_world, mem_t* mem_sprite, const char* filename);
void load_level(mem_t* mem_level, i32 world_id, const char* filename);
void load_big_ray(mem_t* buffer);
void LOAD_ALL_FIX(void);
image_t LoadPcxInVignet(mem_t* buffer, i32 resource_id, i16* width, i16* height, rgb_palette_t* pal_to_save);
void LoadPcxPaletteInVignet(i32 resource_id, rgb_palette_t* palette);
void LoadPlan0InVignet(i32 resource_id);
u8* allocate_PLAN0(mem_t* mem_world, i32 width, i32 height);
void PLAN0FND_to_bits_planes(u8* buffer, i16 width, i16 height);
void LoadPlan2InVignet(mem_t* buffer, i32 resource_id);
char* GetStringTxt(char* txt, char* out_buf);
void LoadLanguageTxt(mem_t* mem, i32 language_index);
void LoadPcxOptions(u8* buffer, i32 resource_id, i16* width, i16* height, rgb_palette_t* pal_to_save);

// luciole.c
void get_luciole(void);
void CLEAR_FIXE_LUCIOLE(void);
void set_luciole(i32 a1, i32 a2);
void init_aff_luciole(i32 a1, i32 a2);
void plot2line(i32 a1, i32 a2, i32 a3, i32 a4, i32 a5);
void aff_luciole(i32 a1, i32 a2, i32 a3, i32 a4);
void Display_and_free_luciole(u8* draw_buf);
void free_luciole(void);
void INIT_LUCIOLE(void);
void DO_LUCIOLE(void);

// menu.c
void LOAD_FND(void);
void INIT_FND(void);
void calc_off_fnd(void);
void check_key_table(void);
void LOAD_CONFIG(void);
void NewFrequency(u8 a1);
void InitClipping(void);
bool IsBackgroundOn(void);
void init_key2txt(void);
void DO_NEW_MENUS(void);
void DO_OPTIONS_IN_GAME(void);
void INIT_GENERAL_CHOICE(void);
void AFFICHE_ECRAN_GENERAL(void);
void DO_COMMANDE_GENERAL(void);
void END_GENERAL_SCREEN(void);
void INIT_OPTIONS_CHOICE(void);
void INIT_AFFICHE_ECRAN_OPTIONS(void);
void AFFICHE_ECRAN_OPTIONS(void);
void DO_COMMANDE_OPTIONS(void);
void END_OPTIONS_SCREEN(void);
void INIT_KEY_SCREEN(void);
void INIT_AFFICHE_KEY_SCREEN(void);
void AFFICHE_KEY_SCREEN(void);
void DO_COMMANDE_KEY(void);
void END_KEY_SCREEN(void);
void INIT_BUTTON_SCREEN(void);
void INIT_AFFICHE_BUTTON_SCREEN(void);
void AFFICHE_BUTTON_JOYSTICK(void);
void DO_BUTTON_COMMANDE(void);
void END_BUTTON_COMMAND(void);
void INIT_PAD_SCREEN(void);
void INIT_AFFICHE_PAD_SCREEN(void);
void AFFICHE_PAD_SCREEN(void);
void DO_COMMANDE_PAD(void);
void END_PAD_SCREEN(void);
void InitParamGraphicsScreen(void);
void INIT_GRAPHIC_SCREEN(void);
void INIT_AFFICHE_GRAPHIC_SCREEN(void);
void AFFICHE_GRAPHIC_SCREEN(void);
void DO_COMMANDE_GRAPHIC(void);
void END_GRAPHIC_SCREEN(void);
void INIT_VIDEOMODE_SCREEN(void);
void INIT_AFFICHE_VIDEOMODE_SCREEN(void);
void AFFICHE_VIDEOMODE_SCREEN(void);
void DO_COMMANDE_VIDEOMODE(void);
void END_VIDEOMODE_SCREEN(void);
void INIT_CALIBRATE_JOYSTICK(void);
void AFFICHE_CALIBRATE_JOYSTICK(void);
void calibrate_joystick_prg(void);
void AFFICHE_CENTER_JOYSTICK(void);
void center_joystick_prg(void);
void MAIN_CALIBRATE_JOYSTICK(void);
i16 menu_prg(u32 a1);
void DO_INTER_MENU(void);
void DO_MENU(void);
void default_key(void);
void new_key(void);
i32 CalcSpeed(void);
void general_init_screen(i16 a1, i16 a2, i16 a3);
void TestCompteur(void);
void TestButtonReleased(void);
void display_box_text_plasma(display_item_t* box, u8 a2);
void display_box_text_fire(display_item_t* a1);
i16 display_box_msg_prg(u32 a1);
void display_box_msg(display_item_t* box);
void display_box_msg_commande(display_item_t* box, void_func_t commande_box_func);
void AfficheYesNo(void);
void DO_YESNOBIS(void);
u8 confirmation_msg(u8 which_message);
void SYNCHRO_LOOP_PALETTE(void* func);
void apparition_prg(void);
void fondu_prg(void);
void change_couleur_prg(void);
void FonduOption(i16 x, i16 y, i16 w, i16 h, u8 a5);
i16 FonduPixel_prg(u32 a1);
void FonduPixel(i16 x, i16 y, i16 w, i16 h);

// meredenis.c
void findMereDenisWeapon(void);
void mereDenisCanAttak(obj_t* obj);
void setMereDenisAtScrollBorder(obj_t* obj);
void setCirclePointToReach(obj_t* obj);
void allocateMereDenisBombChips(obj_t* obj);
void mereDenisExplodeBombs(obj_t* obj);
void mereDenisDropBomb(obj_t* obj);
void swapWeaponAnimState(obj_t* obj);
void swapMereDenisCollZones(obj_t* obj, u8 a2);
void prepareNewMereDenisAttack(obj_t* obj);
void snapLaserToWeapon(obj_t* obj);
void allocateSpaceMamaLaser(obj_t* obj);
void doMereDenisCommand(obj_t* obj);
void changeMereDenisPhase(obj_t* obj);
void fitSaveCurrentAction(obj_t* obj);
void doMereDenisHit(obj_t* obj, i16 sprite);
void mereDenisBigLaserCommand(obj_t* obj);
void mereDenisBombCommand(obj_t* obj);

// mite.c
void mite_esquive_poing(obj_t* mit_obj, i16* out_diff_x);
u8 HAS_MIT_JUMP(obj_t* obj);
u8 ray_over_mit(obj_t* obj, i16 a2);
void fix_mit_Xspeed(obj_t* obj, i16 a2);
void DO_MIT_ATTAK(obj_t* obj);
u8 IS_MIT_PAF(obj_t* obj);
void DO_MIT_COMMAND(obj_t* obj);
void DoMitePoingCollision(obj_t* obj, i16 sprite);
void DO_MITE2_COMMAND(obj_t* obj);
void DoMite2PoingCollision(obj_t* obj, i16 sprite);
void DO_MITE2_ESQUIVE(obj_t* mit2_obj);

// moskito.c
void getIdealStingCoords(obj_t* obj, i16* out_x, i16* out_y);
u8 closeEnoughToSting(obj_t* obj, i16 min_x, i16 min_y);
u8 moskitoCanAttak(obj_t* obj);
i16 setMoskitoAtScrollBorder(obj_t* obj, u8 a2);
void prepareNewMoskitoAttack(obj_t* mst_obj);
obj_t* allocateMoskitoFruit(obj_t* mst2_obj);
void moskitoDropFruitOnRay(obj_t* obj);
void doMoskitoCommand(obj_t* obj);
u8 tellNextMoskitoAction(obj_t* obj);
void changeMoskitoPhase(obj_t* obj);
void doMoskitoHit(obj_t* obj, i16 sprite);
void DO_MST_SCROLL_COMMAND(obj_t* obj);
void DO_MST_CHANGE_COMMAND(obj_t* obj);
void DoMstShakyFruitRaymanZDD(obj_t* obj);

// moteur.c
void INIT_HORLOGES(void);
void horloges(u8 ticks);
void init_allowed_time(void);
void fades(void);
i16 frapsol(i16 a1);
void DO_SCREEN_TREMBLE(void);
void DO_SCREEN_TREMBLE3(void);
void DO_SCREEN_TREMBLE2(void);
void DO_SCROLL(i16* h_speed, i16* v_speed);
void allocateLandingSmoke(obj_t* in_obj);
i32 instantSpeed(i16 speed);
void SET_X_SPEED(obj_t* obj);
void make_active2(obj_t* obj, u8 do_nova);
void make_active(obj_t* obj, u8 do_nova);
bool in_action_zone(i16 screen_x, i16 screen_y, obj_t* obj, u8 active);
void kill_obj(obj_t* obj);
void SET_ACTIVE_FLAG(i16 screen_x, i16 screen_y, obj_t* obj);
i32 DO_PESANTEUR(obj_t* obj);
void freezeAnim(obj_t* obj, u8 a2);
void DO_ANIM(obj_t* obj);
i16 prof_in_bloc(obj_t* obj);
void do_boing(obj_t* obj, u8 main_etat, u8 sub_etat);
u8 underSlope(obj_t* obj);
void DO_STONEBOMB_REBOND(obj_t* obj);
void DO_THROWN_BOMB_REBOND(obj_t* obj, i16 pesanteur, i16 a3);
void DO_FRUIT_REBOND(obj_t* obj, i16 pesanteur, i16 a3);
void Drop_Atter(obj_t* obj);
void BadGuyAtter(obj_t* obj);
void MiteAtter(obj_t* obj);
void LidolPinkAtter(obj_t* obj);
void stoneDogAtter(obj_t* obj);
void stoneDogBounces(obj_t* obj);
void Spider_Atter(obj_t* obj);
void NormalAtter(obj_t* obj);
void OBJ_IN_THE_AIR(obj_t* obj);
void test_fall_in_water(obj_t* obj);
void MOVE_OBJECT(obj_t* obj);
void DO_RAY_IN_ZONE(obj_t* obj);
void DoRaymanInZDDDefault(obj_t* obj);
void DO_ONE_OBJECT(obj_t* obj);
void build_active_table(void);
void Add_One_RAY_lives(void);
void DO_CLING_ANIMS(void);
void DO_OBJECTS_ANIMS(void);
void DO_OBJECTS(void);
void MOVE_OBJECTS(void);
void RECALE_ALL_OBJECTS(void);
u8 RayCoince(i16 dir);
void move_up_ray(void);
void move_down_ray(void);
void recale_ray_pos(void);
void RAY_TO_THE_RIGHT(void);
void RAY_TO_THE_LEFT(void);
void DO_FIXE(void);
void deactivate_ship_links(void);
u8 linkListHoldsAGendoor(obj_t* obj);
void correct_gendoor_link(u8 a1);
void suppressFromLinkList(obj_t* obj);
void correct_link(void);
void INIT_RAY_BEGIN(void);
void INIT_RAY(u8 new_lvl);
u8 is_icy_pente(u8 btyp);
void STOPPE_RAY_EN_XY(void);
void DO_PLACE_RAY(void);
void DO_AUTO_SCROLL(void);
void INIT_MOTEUR(u8 new_lvl);
void INIT_MOTEUR_BEGIN(void);
void INIT_MOTEUR_WORLD(void);
void INIT_MOTEUR_LEVEL(i16 a1);
void restore_gendoor_link(void);
void DONE_MOTEUR_LEVEL(void);
void INIT_MOTEUR_DEAD(void);
void INIT_RAY_ON_MS(void);
void DO_MOTEUR(void);
void DO_MOTEUR2(void);
void RAY_REVERSE_COMMANDS(void);
void RAY_DEMIRAY(void);
void Ray_RayEcrase(void);
void DO_MOTEUR_GELE(void);

// neige.c
void DoFirstFlocons(void);
void add_one_floc(void);
void add_256_flocs(void);
void sub_one_floc(void);
void init_flocons(void);
void do_flocons(i16 x, i16 y, i16 x_old, i16 y_old);
void set_snow_sequence(i16 seq, i16 len);
void set_SNSEQ_list(i16 a1);
void DO_SNOW_SEQUENCE(void);
void DoNeigeRaymanCollision(obj_t* obj);

// map.c
void deter_vide_plein_panach(void* a1, i16 a2);
void deter_nb_blocks(void* a1, i16 a2, i16 a3, i32* a4, i32* a5);
void Copy_Blocks(mem_t* buffer, void* a2, i16 a3, i16 a4);
void construct_MAP(mem_t* mem, big_map_t* big_map, void* map_blocks);
void init_build_map(big_map_t* a1);
void update_display_map(big_map_t* a1);
void set_default_Bloc_clipping(void);
void set_xymapini(void);
void set_xymap(void);
void set_whmap(i32 a1, i32 a2, void* a3);
void recaleRaysurlesBords(void);
void set_xywhmap(i16 xmin, i16 xmax, i16 ymin, i16 ymax);
void MaskScrollDiffSprites(mem_t* buffer);
void DRAW_MAP(u8* draw_buf, big_map_t* big_map);
void INIT_GAME_MODE_NORMAL(void);
void FIN_GAME_MODE_NORMAL(void);

// ngawe.c
void ngaweFollowsShip(obj_t* obj);
void ngaweTriesToGrabShip(obj_t* obj);
void allocatePirateNgaweRing(obj_t* obj, i16 a2, u8 a3);
void DO_NGW_TIR(obj_t* obj);
void NGW_REACT_TO_RAY_IN_ZONE(obj_t* obj);
void DO_ONE_NGW_COMMAND(obj_t* obj);
void DO_NGW_POING_COLLISION(obj_t* obj, i16 sprite);
void DO_ONE_NGW_RING_COMMAND(obj_t* obj);

// mathutil.c
void set2bits(u32 * x, u8 index, u32 value);
u32 read2bits(u32* x, u8 index, u32* high_bit, u32* low_bit);
void setbit(u8 *buffer, u16 index);
void clearbit(u8 *buffer, u16 index);
u8 getbit(u8 *buffer, u16 index);
i32 reflexion(i32 a1, i32 a2);
i32 ashl16(i16 x, u8 bits);
i16 ashr16(i16 x, u8 bits);
i32 ashl32(i32 x, u8 bits);
i32 ashr32(i32 x, u8 bits);
i32 sgn(i32 x);
i32 cosinus(i32 x);
i32 sinus(i32 x);
void sinus_cosinus(i32 x, i16 *cosinus_result, i16 *sinus_result);
i32 abs_sinus(i32 x);
i32 abs_cosinus(i32 x);
void abs_sinus_cosinus(i32 x, i16 *sinus_result, i16 *cosinus_result);

// objinit.c
u8 Prio(obj_t* obj);
void first_obj_init(obj_t* obj);
void obj_init(obj_t* obj);
void init_struct_level(void);
void INIT_OBJECTS(u8 a1);
void REINIT_OBJECT(obj_t* obj);
void special_flags_init(void);

// objupdate.c
void popCmdContext(obj_t* obj);
i16 char2short(u8 x);
u8 readNoArg(obj_t* obj);
u8 skipNoArg(obj_t* obj);
u8 readOneArg(obj_t* obj);
u8 readTestArgs(obj_t* obj);
u8 readGoXYargs(obj_t* obj);
u8 readSpeedArgs(obj_t* obj);
u8 readInvalidArg(obj_t* obj);
u8 skipOneArg(obj_t* obj);
u8 skipTestArgs(obj_t* obj);
u8 skipGoXYArgs(obj_t* obj);
u8 skipSpeedArgs(obj_t* obj);
u8 handle_SELF_HANDLED(obj_t* obj);
u8 skipInvalidArg(obj_t* obj);
u8 handle_11_GO_LABEL(obj_t* obj);
u8 handle_19_GO_WAITSTATE(obj_t* obj);
u8 handle_25_RESERVED_GO_GOSUB(obj_t* obj);
u8 handle_RESERVED_GO_SKIP_and_RESERVED_GO_GOTO(obj_t* obj);
u8 handle_26_RESERVED_GO_BRANCHTRUE(obj_t* obj);
u8 handle_27_RESERVED_GO_BRANCHFALSE(obj_t* obj);
u8 handle_28_RESERVED_GO_SKIPTRUE(obj_t* obj);
u8 handle_29_RESERVED_GO_SKIPFALSE(obj_t* obj);
u8 handle_21_GO_X(obj_t* obj);
u8 handle_22_GO_Y(obj_t* obj);
u8 handle_12_GO_GOTO(obj_t* obj);
u8 handle_8_GO_STATE(obj_t* obj);
u8 handle_5_GO_SUBSTATE(obj_t* obj);
u8 handle_6_GO_SKIP(obj_t* obj);
u8 handle_9_GO_PREPARELOOP(obj_t* obj);
u8 handle_13_GO_GOSUB(obj_t* obj);
u8 handle_14_GO_RETURN(obj_t* obj);
u8 handle_10_GO_DOLOOP(obj_t* obj);
u8 handle_33_INVALID_CMD(obj_t* obj);
u8 handle_15_GO_BRANCHTRUE(obj_t* obj);
u8 handle_16_GO_BRANCHFALSE(obj_t* obj);
u8 handle_31_GO_SKIPTRUE(obj_t* obj);
u8 handle_32_GO_SKIPFALSE(obj_t* obj);
u8 handle_18_GO_SETTEST(obj_t* obj);
u8 handle_17_GO_TEST(obj_t* obj);
u8 readOneCommand(obj_t* obj);
u8 skipOneCommand(obj_t* obj);
void GET_OBJ_CMD(obj_t* obj);
void pushCmdContext(obj_t* obj, u8 count);
void skipToLabel(obj_t* obj, u8 label, u8 skip_label_cmd);
void pushToLabel(obj_t* obj, u8 label, u8 skip_label_cmd);
void ObjectUTurnDefault(obj_t* obj);
void DO_WIZARD(obj_t* obj);
i32 get_next_bonus_level(u8 lev);
void TEST_WIZARD(obj_t* obj);
void DO_TARZAN(obj_t* tz_obj);
void DoTarzanPoingCollision(obj_t* obj, i16 sprite);
void allocate_badguy(obj_t* tentacle_obj, i16 which_enemy, i16 xspeed, i16 yspeed);
void DO_PTI_ESQUIVE(obj_t* obj);
void DoPrisePoingCollision(obj_t* obj, i16 sprite);
void DO_PETIT_COUTEAU_COMMAND(obj_t* obj);
void DoPetitCouteauPoingCollision(obj_t* obj, i16 sprite);
void DO_TIRE_BOUCHON_COMMAND(obj_t* obj);
void DoOneUpPoingCollision(obj_t* obj, i16 sprite);
void DoOneUpRaymanCollision(obj_t* obj);
void DoMorningStarPoingCollision(obj_t* obj, i16 sprite);
void DoGrapBonusRaymanCollision(obj_t* obj);
void DoPoingPowerupRaymanCollision(obj_t* obj);
void DoPowerupRaymanCollision(obj_t* obj);
void DoSuperHelicoRaymanCollision(obj_t* obj);
void DoGraineRaymanCollision(obj_t* obj);
void DoWizRaymanCollision(obj_t* obj);
void DoJaugeUpRaymanCollision(obj_t* obj);
void DoGeneratingDoorRaymanCollision(obj_t* obj);
void DO_REDUCTEUR(obj_t* obj);
void DoReducteurRaymanCollision(obj_t* obj);
void DoSignPostRaymanCollision(obj_t* obj);
void TEST_SIGNPOST(void);
void DoPancarteRaymanCollision(obj_t* obj);
void DO_MUSICIEN(obj_t* obj);
void DoMusicienRaymanInZDD(obj_t* obj);
void DO_TEN_COMMAND(obj_t* obj);
void DoGeneBadGuyPoingCollision(obj_t* obj, i16 sprite);
void DoGeneBadGuyRaymanZDD(obj_t* obj);
void DoChasseurPoingCollision(obj_t* obj, i16 sprite);
void DoChasseurRaymanZDD(obj_t* obj);
void DO_CHASSEUR_COMMAND(obj_t* obj);
void DoBadGuy23PoingCollision(obj_t* obj, i16 sprite);
void DoBadGuy23RaymanZDD(obj_t* obj);
void DoBadGuy1PoingCollision(obj_t* obj, i16 sprite);
void DoBadGuy1RaymanZDD(obj_t* obj);
void DO_CCL_COMMAND(obj_t* obj);
void DoCaisseClairePoingCollision(obj_t* obj, i16 sprite);
void DoCaisseClaireRaymanZDD(obj_t* obj);
void DoStalagRaymanZDD(obj_t* obj);
void DO_ENSEIGNE_COMMAND(obj_t* obj);
void DO_JOE_COMMAND(obj_t* obj);
void DoJoeRaymanZDD(obj_t* obj);
void DO_BOUEE_JOE_COMMAND(obj_t* obj);
void DO_PHOTOGRAPHE_CMD(obj_t* obj);
void DoAudioStartRaymanCollision(obj_t* obj);
void DO_SLOPEY_PLAT_CMD(obj_t* obj);
void DO_PIRATE_POELLE(obj_t* obj);
void DO_PIRATE_POELLE_POING_COLLISION(obj_t* obj, i16 sprite);
void PIRATE_POELLE_REACT(obj_t* obj);
void DO_SPECIAL_PLATFORM(obj_t* obj);
void DoPlatformPoingCollision(obj_t* obj, i16 sprite);

// pmama.c
void pmamaFollowsShip(obj_t* obj);
void init_couteaux(void);
void reset_couteax(void);
void check_couteaux(void);
i8 find_couteau(obj_t* obj);
i32 x_pos(u8 a1, u8 a2);
i32 y_pos(i16 a1, i16 a2);
i32 y_floor(i16 a1, i16 a2);
void init_move_couteau(obj_t* obj);
void init_lance_couteau(u8 a1);
void couteau_frame(i16 a1, i16 a2);
void update_couteau(obj_t* obj);
void get_cou_zdc(obj_t* obj, i16 *x, i16 *y, i16 *w, i16 *h);
void pma_attaque_suivante(void);
i16 convertspeed(i16 x);
void lance_couteau_parabolique(obj_t* obj);
void lance_couteau_droit(obj_t* obj);
void retour_couteau(obj_t* obj);
void lance_couteau_lineaire(obj_t* obj);
void DO_COU_COMMAND(obj_t* obj);
void calc_pma_dir(obj_t* obj);
void DO_PMA_COMMAND(obj_t* obj);
void init_mama_pirate(obj_t* obj);
void PMA_SORT_DU_CANON(obj_t* obj);
void DO_PMA_POING_COLLISION(obj_t* obj, i16 sprite);
i32 pma_get_eject_sens(obj_t* obj);
void DO_COU_ATTER(obj_t* obj);
void DO_PMA_ATTER(obj_t* obj);

// poing.c
void fist_U_turn(u8 a1);
void CALC_FIST_POS(void);
void RAY_THROW_FIST(void);
void RAY_PREPARE_FIST(void);
void RAY_GROW_FIST(void);
void fin_poing_follow(u8 a1);
void POING_FOLLOW(obj_t* obj);
void alter_fist_speed(obj_t* obj);
void switch_off_fist(void);
void DO_POING(obj_t* obj);
void allocatePoingBoum(void);

// poisson.c
void DO_POISSON_VERT_CMD(obj_t* obj);
void DO_POISSON_BLEU_CMD(obj_t* obj);
void DoPoissonBleuPoingCollision(obj_t* obj, i16 sprite);
bool can_free_fish(obj_t* fish);
void DESACTIVE_FISH_COLLIS(obj_t* fish);
void DO_PYRANHA(obj_t* obj);
void DoFishPoingCollision(obj_t* obj, i16 sprite);
void DoPoissonBleuRaymanZDD(obj_t* obj);

// worldmap.c
void TEST_DISPLAY_PTS_WAY(i16 world, i16 connected_world, i16 xpos, i16 ypos);
void DISPLAY_PTS_WAY(void);
void DISPLAY_PLAT_WAY(void);
void DO_MEDAILLONS(void);
void INIT_LEVEL_STAGE_NAME(void);
void INIT_WORLD_STAGE_NAME(void);
void INIT_STAGE_NAME(void);
void CHANGE_STAGE_NAMES(void);
void DO_STAGE_NAMES(void);
void INIT_WORLD_INFO(void);
void INIT_LITTLE_RAY(void);
void RESTORE_RAY(void);
void INIT_CHEMIN(void);
void RESPOND_TO_UP(void);
void RESPOND_TO_DOWN(void);
void RESPOND_TO_RIGHT(void);
void RESPOND_TO_LEFT(void);
void DO_RAYMAN_IN_WLD_MAP(void);
void DO_CHEMIN(void);
void INIT_PASTILLES_SAUVE(void);
void PASTILLES_SAUVE_SAVED(i16 world);
void FIN_WORLD_CHOICE(void);
void DETER_WORLD_AND_LEVEL(void);
void INIT_NEW_GAME(void);
void DO_NOT_SAVE_CHOICE(void);
void INIT_SAVE_CHOICE(void);
void INIT_SAVE_CONTINUE(void);
void DO_COMMANDE_SAVE(void);
void SELECTION_SAVE_OPTION(void);
void INIT_AFFICHE_ECRAN_SAVE(void);
void SAISIE_NOM(void);
void REALISATION_ACTION(void);
void DISPLAY_SYMBOLE(i16 a1, i16 a2, i16 a3, u8 a4);
void INIT_CONTINUE(void);
void CHEAT_MODE_CONTINUE(void);
void MAIN_CONTINUE_PRG(void);
void FIN_CONTINUE_PRG(void);
void INIT_NO_MORE_CONTINUE(void);
void MAIN_NO_MORE_CONTINUE_PRG(void);
void INIT_VIGNET(void);
void INIT_CREDITS(void);
void DO_CREDITS(void);
void INIT_ANIM_VICTOIRE(void);
void DO_RAYMAN_WINS(void);
void INIT_LOADER_ANIM(void);
void DO_LOADER_ANIM(void);
void SPECIAL_INIT(void);
void INIT_LEVEL_ANIM(void);
void DO_LEVEL_ANIM(void);
void FIN_LEVEL_ANIM(void);

// rand.c
i16 myRand(i16 max);
void MakeMyRand(i32 set_seed);

// ray.c
void allocateRayLandingSmoke(void);
void recale_ray_on_liane(void);
void calc_bhand_typ(void);
void IS_RAY_ON_LIANE(void);
void rayMayLandOnAnObject(u8* a1, i16 obj_id);
void set_air_speed(u8 main_etat, u8 sub_etat, i16 param_3, u8 param_4);
void Reset_air_speed(u8 is_rolling_speed);
void determineRayAirInertia(void);
void ray_jump(void);
void ray_inertia_speed(i16 a1, i16 a2, i16 prev_speed_x, i16 a4);
void RAY_SWIP(void);
void RAY_STOP(void);
void RAY_HELICO(void);
void Make_Ray_Hang(i16 a1, i16 a2);
bool AIR(i32 a1);
bool MUR(i32 a1);
void CAN_RAY_HANG_BLOC(void);
void RAY_TOMBE(void);
void RAY_RESPOND_TO_DOWN(void);
void RAY_RESPOND_TO_UP(void);
void RAY_RESPOND_TO_DIR(i16 flip_x);
void RAY_RESPOND_TO_NOTHING(void);
void RAY_RESPOND_TO_BUTTON3(void);
void RAY_RESPOND_TO_FIRE0(void);
void RAY_RESPOND_TO_FIRE1(void);
i16 RAY_BALANCE_ANIM(i16 grp_angle);
void SET_RAY_BALANCE(void);
void RAY_GOING_BALANCE(obj_t* obj);
void RAY_BALANCE(void);
void RAY_FIN_BALANCE(void);
void RayTestBlocSH(void);
void remoteControlRay(void);
void STOPPE_RAY_CONTRE_PAROIS(u8 block);
void RAY_IN_THE_AIR(void);
void terminateFistWhenRayDies(void);
void snifRayIsDead(obj_t* obj);
void rayfallsinwater(void);
u8 RAY_DEAD(void);
void RAY_HURT(void);
void RepousseRay(void);
u8 RayEstIlBloque(void);
void stackRay(void);
void RAY_SURF(void);
void DO_SURF_CHANGE_HAIRS(void);
void DO_PIEDS_RAYMAN(obj_t* obj);
void DO_MORT_DE_RAY(void);
void TEST_FIN_FOLLOW(void);
void RAY_FOLLOW(void);
void RAY_RESPOND_TO_ALL_DIRS(void);
void DO_RAY_ON_MS(void);
void DO_RAYMAN(void);
void INIT_PC(void); // NOTE: maybe these need to be moved to a separate source file?
void FIN_PC(void);
void updateLogo(i32 fade_duration, i32 a2, i32 a3);
void LOAD_SCREEN(void);
void sub_71A84(void);
void sub_71A98(void);
void DO_UBI_LOGO(void);

// save.c
void initGameSave(void);
void doneGameSave(void);
void saveGameState(obj_t* save_obj, save_state_t* save_state);
void restoreGameState(save_state_t* save_state);
i32 get_offset_in_safe_zone(i16 obj_id);
void reset_save_zone_level(void);
void take_bonus(i16 obj_id);
u8 bonus_taken(i16 obj_id);
void storeWorldInfoAcces(void);
void retrieveWorldInfoAccess(void);
void file_size(void);
void SaveGameOnDisk(u8 which_save);
bool LoadGameOnDisk(u8 which_save);
bool LoadInfoGame(u8 which_save);
bool SaveOptionsOnDisk(void);
bool LoadOptionsOnDisk(void);

// saxo.c
void saxoCanAttak(void);
void INIT_SAXO(obj_t* obj);
void allocateNote2(obj_t* note_obj, i16 a2);
void DO_EXPLOSE_NOTE2(obj_t* obj);
void DO_NOTE_CMD(obj_t* obj);
void Cree_Eclat_Note(obj_t* bnote, obj_t* note1, i16 index);
void DO_EXPLOSE_NOTE1(obj_t* obj);
void BonneNote(obj_t* orig_obj);
void DO_NOTE_TOUCHEE(obj_t* obj, i16 sprite);
void DO_NOTE_REBOND(obj_t* obj);
void allocateNote(obj_t* obj);
u8 PrepareAtak(void);
void SAXO_TIRE(obj_t* obj);
void DO_SAXO_COUP(obj_t* obj);
void DO_SAXO2_COUP(obj_t* obj);
void SetSaxoEventPos(obj_t* obj);
void SetSaxoCollNoteBox(obj_t* obj);
void DO_SAXO_COMMAND(obj_t* obj);
void DO_SAXO_ATTER(obj_t* obj);
void DO_SAXO2_COMMAND(obj_t* obj);
void DO_SAXO2_ATTER(obj_t* obj);
void DO_SAXO_MARCHE(obj_t* obj);
void DO_SAXO3_COMMAND(obj_t* obj);
void DO_SAXO3_DEBUT(obj_t* obj);
i32 saxo2_get_eject_sens(void);

// screen.c
void Init_Bande(u8 fnd, i16 width, i16 height, u8* source_buf, u8* dest_buf);
void Display_Back_Screen(i16 plan_width, i16 plan_height, i16 w1, i16 h1, i16 w2, i16 h2);
void Display_Sprite_On_Front(i16 plan_width, i16 plan_height, i16 w1, i16 h1, i16 w2, i16 h2);
void Calcul_Deplacement_Bande(i16 x, i16 plan_width, i16 plan_height);
void Init_Effet_Chaleur(i16 width, i16 height, u8* source_buf, u8* dest_buf);
void Do_Effet_Chaleur(i16 a1, i16 a2);

// skops.c
void swap(i32 a1, i32 a2);
void set_rubis_list(void);
void allocate_rayon(i16 a1, i16 a2);
void allocate_8_petits_rayons(i16 a1, i16 a2);
void do_sko_rayon(void);
void do_sko_rayon2(void);
void start_sko_rayon(i16 a1, i16 a2);
void start_sko_rayon2(i16 a1, i16 a2);
void lance_pince(i32 a1);
i32 sko_get_eject_sens(void);
void DO_SOL_ENFONCE(void);
void DO_SKO_PHASE_0(obj_t* obj);
void DO_SKO_PHASE_1(obj_t* obj);
void DO_SKO_PHASE_2(obj_t* obj);
void DO_SKO_PHASE_3(obj_t* obj);
void DO_SKO_PINCE(obj_t* obj);
void DO_SCORPION_COLLISION(obj_t* obj);
void DO_SCORPION_MORT(obj_t* obj);
void DO_SKO(obj_t* obj);
void SKO_ray_in_zone(obj_t* obj);
void DO_SKO_HIT(obj_t* obj, i16 sprite);
i16 Get_PosLave_Y(void);

// special.c
void new_level_init(void);
void fix_numlevel(obj_t* obj);
void allocate_splash(obj_t* obj);
void DO_BALLE(obj_t* obj);
void DO_TIR(obj_t* obj);
void DO_INTERACT_PLAT(obj_t* obj);
obj_t* oldest_planted(void);
void DO_GROWING_PLATFORM(void);
obj_t* allocateExplosion(obj_t* obj);
void BombExplosion(obj_t* obj);
void MARACAS_GO(obj_t* obj);
i16 ANGLE_RAYMAN(obj_t* obj);
obj_t* allocateNOVA(void);
void DO_NOVA(obj_t* obj);
void DO_NOVA2(obj_t* obj);
i16 NOVA_STATUS_BAR(void);
void DO_REDEYE_FIRE(i16 a1, i16 a2, i16 a3);
void calc_esquive_poing(obj_t* mit_obj, i16* out_diff_x, i16* out_diff_y, i16* out_unk);
i16 allocate_gerbe(void);
void start_pix_gerbe(i16 a1, i16 a2);
void do_pix_gerbes(void);
void START_2_PARTS_CYMBAL_ACTION(obj_t* obj);
void ChangeLevel(void);
void init_moustique(void);
void DO_CORDE_CASSE(obj_t* obj);
void DO_FUMEE_CORDE(i16 x, i16 y);
i32 GetY(i16 x);
void allocateSupHelico(obj_t* mus_obj);
void allocatePaillette(obj_t* obj);
void test_fin_cling(void);

// stoneman.c
void DO_STONEMAN_COMMAND(obj_t* obj);
void DO_STONEDOG_COMMAND(obj_t* obj);
void DoStoneDogPoingCollision(obj_t* obj, i16 sprite);
void DO_STONEBOMB_COMMAND(obj_t* obj);
void IS_STONEWOMAN_WAIT(obj_t* obj);
void DO_STONEWOMAN_COMMAND(obj_t* obj);
void DO_NOMOVE_STONEWOMAN_COMMAND(obj_t* obj);
void DO_ONE_STONECHIP_COMMAND(obj_t* obj);
void setStoneChipPos(obj_t* obj1, obj_t* obj2, u8* param_3);
void allocateStoneChips(obj_t* obj);
void DO_STONE_EXPLOSION(obj_t* obj, i16 sprite);
void allocateStonemanStone(obj_t* obj);
void DO_STONEMAN1_TIR(obj_t* obj);
void DO_STONEMAN2_TIR(obj_t* obj);
void allocateStonewomanStone(obj_t* obj);
void DO_STONEWOMAN_TIR(obj_t* obj);
void allocateEclatPS(obj_t* obj, i16 param_2);
void DO_PI_EXPLOSION(obj_t* obj);
void DoPiMusPoingCollision(obj_t* obj, i16 sprite);
void DoPiPoingCollision(obj_t* obj, i16 sprite);
void DO_PNG_COLL_STONEMAN(obj_t* obj, i16 sprite);
void DO_PNG_COLL_STONEWOMAN(obj_t* obj, i16 sprite);
void DoStoneMan1et2RaymanZDD(obj_t* obj);
void DoStoneDogRaymanZDD(obj_t* obj);

// trumpet.c
void DO_TRP_COMMAND(obj_t* obj);
void trompetteWind(obj_t* obj, u8 a2);
void DO_TRP_ATTAK(obj_t* obj);
void trompetteAtter(obj_t* obj);
void DoTrumpetPoingCollision(obj_t* obj, i16 sprite);
void DoTrompetteRaymanZDD(obj_t* obj);

// ufo.c
void test_block_chdir(obj_t* obj, i16 a1, i16 a2);
void DO_MOVING_WITH_INDICATOR_COMMAND(obj_t* obj);
void DO_IDC_COMMAND(obj_t* obj);
void DO_LEV_POING_COLLISION(obj_t* obj, i16 sprite);
void START_UFO(obj_t* obj);

// The function prototypes below are from misc source files (may need some cleanup).

// engine.c
void advance_frame(void);
void game_init_sound(game_sound_buffer_t* sound, i32 samples_per_second);
void game_init(game_state_t* game);
void destroy_image(image_t* image);

// platform routines
i64 get_clock(void);
float get_seconds_elapsed(i64 start, i64 end);
// sound.c
void lock_audio(void);
void unlock_audio(void);
void game_get_sound_samples(game_sound_buffer_t* output_buffer);
i16 play_digi_snd(snd_t* snd);
void play_cd_track(i32 track_number);
void stop_cd_music(void);
ogg_t open_cd_vorbis(i32 track_number);
void stop_ogg(ogg_t* ogg);
void play_ogg(game_sound_buffer_t* sound_buffer, ogg_t* ogg);
void manage_snd_event(void);
void SetVolumeSound(i16 volume);
void stop_all_snd(void);
void stop_ray_snd(void);
u8 get_pan_snd(obj_t* obj);
i32 get_vol_snd(obj_t* obj);
void raj_env_sound(i16 volume);
void raj_env_audio(i16 enabled);
bool raj_env_stereo(i16 stereo);
bool InitSnd(void);
i16 last_snd(i32 obj_id);
i32 get_pile_obj(i16 obj_id);
i32 get_voice_obj(i32 obj_id);
i32 get_voice_snd(i32 snd);
i32 get_voice_obj_snd(i16 obj_id, i16 snd);
void erase_pile_snd(i16 obj_id);
void nettoie_pile_snd(void);
void erase_voice_table(i32 obj_id);
u8 snd_in_pile_snd(i16 snd);
i32 vol_r(i16 a1, i16 a2);
i32 vol_l(i16 a1, i16 a2);
void PlaySnd(i16 snd, i16 obj_id);
void PlaySnd_old(i16 sound_id);
void setvol(i16 obj_id);
void setpan(i16 obj_id);
void manage_snd(void);
void mute_snd_bouclant(void);
void mute_snd(void);
void start_freeze_snd(void);
void stop_freeze_snd(void);
void PlayTchatchVignette(i32 snd);
void TestCdLoop(void);
void InitMusic(void);
void DoneMusic(void);

// render.c
void render_weird_gradient(surface_t* surface, int x_offset, int y_offset);
void render_clear(surface_t* surface, rgb_t color);
void surface_blit_palettized_image(image_t* source, rgb_palette_t* palette, rect_t* source_rect, surface_t* target, rect_t* target_rect);

// save.c
void set_medaillion_saved_data(void);
void load_sav(u8 which_save);
void reset_items_and_bosses(void);

// misc_source.c
void SpriteFixeOffset(mem_t* mem);
void SpriteWorldOffset(mem_t* mem);
void SpriteFixeBlocksFree(mem_t* mem);
void SpriteWorldBlocksFree(mem_t* mem);
u8 decode_xor(u8* data, u32 size, u8 encoding_byte, u8 checksum_byte);
void SetPalette(rgb_palette_t* palette, u8 first_color, i32 num_colors);
void set_special_key_descriptions(const char** descriptions);
image_t load_vignet_pcx(u32 resource_id);
void detect_and_remove_invalid_link_cycles();
